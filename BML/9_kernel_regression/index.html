<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>More on Kernel Regression | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content="Having defined kernels, this post delves into how such kernels can be used in the context of linear regression. This results in an extremely powerful model, but also adds computational problems when confronted with vast amounts of data. To over come these problems, we briefly introduce the subset of methods, subset of regressors and random Fourier feature estimates for kernel machines."> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/BML/9_kernel_regression/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "More on Kernel Regression",
      "description": "Having defined kernels, this post delves into how such kernels can be used in the context of linear regression. This results in an extremely powerful model, but also adds computational problems when confronted with vast amounts of data. To over come these problems, we briefly introduce the subset of methods, subset of regressors and random Fourier feature estimates for kernel machines.",
      "published": "February 6, 2024",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>More on Kernel Regression</h1> <p>Having defined kernels, this post delves into how such kernels can be used in the context of linear regression. This results in an extremely powerful model, but also adds computational problems when confronted with vast amounts of data. To over come these problems, we briefly introduce the subset of methods, subset of regressors and random Fourier feature estimates for kernel machines.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#no-sample-noise">No Sample Noise</a></div> <div><a href="#choosing-kernels-not-basis-functions">Choosing Kernels, Not Basis Functions</a></div> <div><a href="#numerical-complexity">Numerical Complexity</a></div> <div><a href="#using-less-points">Using Less Points</a></div> <div><a href="#using-less-features">Using Less Features</a></div> <div><a href="#discussion">Discussion</a></div> </nav> </d-contents> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/8_kernels/">← Kernels</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/10_gaussian_process/">Gaussian processes →</a></span> <br> <br></p> <blockquote> <p>In the previous post we defined kernels, showed how they can be constructed, and even showed how to use them together with ridge regression. In this post, we’re going to take a closer look at kernel ridge regression and the implications of using kernels instead of basis functions.</p> </blockquote> <p>Last time, we basically showed that if we assume a zero-mean, diagonal Gaussian prior on the parameters $\theta\sim\mathcal{N}(0,I\lambda)$ , then the MMSE solution for linear regression is given by:</p> \[\begin{equation} \hat{\theta} = \left(\frac{\sigma^{2}}{\lambda}I+H^{T}H\right)^{-1}H^{T}y =H^{T}\left(\frac{\sigma^{2}}{\lambda}I+HH^{T}\right)^{-1}y \end{equation}\] <p>To predict the function at a new point, we only need to calculate:</p> \[\begin{align} y_{\hat{\theta}}\left(x\right) &amp; =h^{T}\left(x\right)H^{T}\left(\frac{\sigma^{2}}{\lambda}I+HH^{T}\right)^{-1}y\\ &amp; =y^{T}\left(\frac{\sigma^{2}}{\lambda}I+HH^{T}\right)^{-1}Hh\left(x\right) \end{align}\] <p>If we assume that the inner product is given by some kernel, i.e. $h^{T}\left(x\right)h\left(y\right)=k\left(x,y\right)$ , and that $K$ is the Gram matrix of the kernel on the data points $\{x_i \}_{i=1}^{N}$ such that $K_{ij}=k\left(x_{i},x_{j}\right)$, then:</p> \[\begin{align} y_{\hat{\theta}}\left(x\right) &amp; =y^{T}\left(\frac{\sigma^{2}}{\lambda}I+K\right)^{-1}\left(\begin{matrix}h^{T}\left(x_{1}\right)h\left(x\right)\\ \vdots\\ h^{T}\left(x_{N}\right)h\left(x\right) \end{matrix}\right) \\ &amp; =y^{T}\left(\frac{\sigma^{2}}{\lambda}I+K\right)^{-1}\left(\begin{matrix}k\left(x,x_{1}\right)\\ \vdots\\ k\left(x,x_{N}\right) \end{matrix}\right) \\ &amp; =\sum_{i=1}^{N}\left[y^{T}\left(\frac{\sigma^{2}}{\lambda}I+K\right)^{-1}\right]_{i}k\left(x,x_{i}\right) \\ &amp; \stackrel{\Delta}{=}\sum_{i=1}^{N}\alpha_{i}\cdot k\left(x,x_{i}\right)\label{eq:dual-form} \end{align}\] <p>where $N$ is the number of data points we have in the data set. Notice that this problem looks exactly like the regular linear regression, only with new basis functions ($N$ of them).</p> <p>This is called the solution to the <em>dual problem</em>. In fact, we’ve already seen how to find this solution, when we <a href="https://friedmanroy.github.io/BML/6_equiv_form/">derived an equivalent expression for Bayesian linear regression</a>. The main point is that whenever we have the inner product over features $HH^T$, we instead use our trusty kernel.</p> <p><br></p> <h1 id="no-sample-noise">No Sample Noise</h1> <p>Notice that if we take $\sigma^{2}=0$, the solution becomes:</p> \[\begin{equation} f\left(x\right)=h^{T}\left(x\right)H^{T}K^{-1}y \end{equation}\] <p>in which case we have to assume that the Gram matrix is invertible for there to be a solution. Since the Gram matrix is PSD (by definition), the only way that it can be invertible is if it is PD as well, i.e. if the kernel $k\left(\cdot,\cdot\right)$ is a PD kernel.</p> <p>Anyway, let’s look at the prediction of the <em>train points</em>, and see what we get. The prediction in this case will be given by ($\hat{y}$ below is the <em>vector</em> of predictions for all of the training data points $x_{i}$):</p> \[\begin{equation} \hat{y}=HH^{T}K^{-1}y=Iy=y \end{equation}\] <p>and in fact our training error will be 0! What does this tell us?</p> <p>If the kernel $k\left(\cdot,\cdot\right)$ is PD, then it can fit <em>any</em> function. In particular, for any finite set of points $\{ x_{i}\}_{i=1}^{N}$, the set of basis functions $\{ k\left(x,x_{i}\right)\}_{i=1}^{N}$ spans <em>all possible functions</em> that pass through the points $\{ \left(x_{i},y\left(x_{i}\right)\right)\}_{i=1}^{N}$.</p> <p><br></p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_9/rec7_nonoise_RidgeBLR.png" alt="Visualization of noiseless ridge regression" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 1: If the kernel is PD, then regressing without noise fits the training data exactly. In this example, an RBF kernel is used, assuming no noise, and $\beta=0.4$. </div> <p><br></p> <hr> <h4 id="example-rbf-kernel">Example: RBF Kernel</h4> <p>Showing it explicitly is kind of a pain, but the Gaussian kernel is a PD kernel:</p> \[\begin{equation} k\left(x,y\right)=e^{-\beta\vert x-y\vert ^{2}} \end{equation}\] <p>Let’s take a look at the basis functions this kernel induces in the dual form (as in equation \eqref{eq:dual-form}). For any set of training points $\{ x_{i}\}_{i=1}^{N}$, using the Gaussian kernel is like fitting the following linear regression problem:</p> \[\begin{align} f\left(x\right) &amp; =\sum_{i=1}^{N}\alpha_{i}k\left(x,x_{i}\right)\\ &amp; =\sum_{i=1}^{N}\alpha_{i}e^{-\beta\vert x-x_{i}\vert ^{2}}\\ &amp; =\sum_{i=1}^{N}\alpha_{i}\varphi_{x_{i}}\left(x\right) \end{align}\] <p>where $\varphi_{\mu}\left(\cdot\right)$ is the Gaussian basis function centered around the point $\mu$. So, in fact, using kernel ridge regression with a Gaussian kernel is the same as using $N$ Gaussian basis functions, centered around each of the data points. This (hopefully) makes sense - if we have a Gaussian around each data point $x_{i}$, then finding the weights of each basis function so that they pass through the points $y\left(x_{i}\right)$ sounds easy.</p> <p><br></p> <h1 id="choosing-kernels-not-basis-functions">Choosing Kernels, Not Basis Functions</h1> <p>Up until now, we have been choosing the basis functions we want to use in order to define the linear regression problem. This view of the problem was helpful when we defined the basis functions explicitly, but now that we moved to kernel regression, it is less informative. Now, instead of choosing basis functions, we choose a kernel which (implicitly) defines an inner product between sets of basis functions. But how can we choose the kernels in an informative manner?</p> <p>When choosing kernels, instead of basis functions, we want to choose the expected behavior of the regressed function - how smooth it looks, how fast it alternates between values, if it’s periodic, etc. In this sense, we change the characteristics of the functions through the kernels. In the dual form (as in equation \eqref{eq:dual-form}), the prior we have over the parameters $\alpha$ is:</p> \[\begin{equation} \alpha\sim\mathcal{N}\left(0,K^{-1}\right) \end{equation}\] <p>where $K$ is the Gram matrix of the training points using the kernel. As we can see, the choice of kernel is directly reflected in our prior. In particular, the kernel controls the structure of the covariance between data points, so it makes sense to choose the kernel to reflect a sense of similarity between points.</p> <p><br></p> <hr> <h4 id="example-changing-the-bandwidth-of-the-rbf-kernel">Example: Changing the Bandwidth of the RBF Kernel</h4> <p>Let’s look at the Gaussian kernel, again.</p> <p>The parameter $\beta$ is called the bandwidth of the kernel, and defines how quickly we expect changes in the data. Specifically, let’s look at the two extremes $\beta\rightarrow\infty$ and $\beta\rightarrow0$:</p> \[\begin{align} \forall x\neq y\quad e^{-\beta\vert x-y\vert ^{2}} &amp; \stackrel{\beta\rightarrow\infty}{=}e^{-\infty}=0\\ e^{-\beta\vert x-y\vert ^{2}} &amp; \stackrel{\beta\rightarrow0}{=}e^{0}=1 \end{align}\] <p>But what does this tell us?</p> <p>Specifically, when $\beta\rightarrow0$, then the estimate of the function becomes:</p> \[\begin{equation} f_{0}\left(x\right)=\sum_{i=1}^{N}\alpha_{i} \end{equation}\] <p>so we are trying to fit a straight line. This means that the kernel we chose expects all values of the function to be the same - given 1 point, we know how all others should behave. We can call this function “infinitely smooth”, in the sense that the fitted line will have no derivative at all. Alternatively we could the function “unragged”, but that sounds a bit weird.</p> <p>On the other hand, when $\beta\rightarrow\infty$ the Gram matrix will be:</p> \[\begin{equation} K_{\infty}=I \end{equation}\] <p>so the prior over the parameters will be the standard normal distribution, so the $x_{i}$-th point doesn’t really care about the value of the function at the $x_{j}$-th point. The MMSE solution in this case is:</p> \[\begin{equation} f_{\infty}\left(x\right)=\begin{cases} 0 &amp; x\not\in\left\{ x_{i}\right\} _{i=1}^{N}\\ y_{i} &amp; x=x_{i} \end{cases} \end{equation}\] <p>This is a kind of useless function as well, since it will only know the values of the function at the points from the training data. The functions we fit with this function can be “infinitely ragged”, in this sense.</p> <p>As we can see, the bandwidth parameter $\beta$ controls “how ragged” we expect the function to be. This sentiment is mirrored in the figure below, where it is really clear that the large $\beta$ value pulls the functions towards more wiggly functions, while the really low value pushes the learned function into a really stretched out curve.</p> <p><br></p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_9/rec7_bandwidth.png" alt="Visualization of noiseless ridge regression" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 2: Effects of the bandwidth ($\beta$) on the functions represented by the kernel regression. Low values of $\beta$ (right) correspond to long-range correlations, and the results are functions closer to a line; intermediate values (center) prefer smooth functions while high values (right) model very short-range interactions, which in practice look like very wiggly functions. These results are easiest to see in the functions sampled from the posterior. </div> <p><br></p> <h1 id="numerical-complexity">Numerical Complexity</h1> <p>Let’s look at the two versions of the MMSE solution again. Recall the matrix $H$ is a $p\times N$ matrix, where $p$ is the number of basis functions and $N$ is the number of points in the training data set. For the primal space we need to invert the matrix $H^{T}H+I\beta$ where $\beta$ is some number, which is a $p\times p$ matrix. In the dual formulation, we need to invert the matrix $HH^{T}+I\beta$ which is an $N\times N$ matrix. Typically, when we use kernels, we want to embed the data points $x_{i}$ into a much higher-dimensional space, so that $p\gg1$. Clearly, using the original linear regression solution is not practical (recall, for RBF kernels we have an infinite number of dimensions in the feature space).</p> <p>Okay… so if we want to use (expressive) feature spaces, we should usually use the dual formulation. Right, so while in the “classical” sense, inverting an $N\times N$ matrix is probably fine (since the number of points isn’t gigantic), in modern machine learning we use millions (if not billions) of data points in order to learn our estimators. Meanwhile, inverting a $1000\times1000$ matrix is already pretty difficult, never mind a $10^{6}\times10^{6}$ matrix which we probably can’t even store in memory<d-footnote>A $10^{6}\times10^{6}$ matrix is the same as storing $10^{12}$ floating point numbers. Assuming we use $32$ bits to store each number, or 4 bytes, the number of bytes we need to keep in memory is $4\times10^{12}$ bytes, which is 4 terabytes of data</d-footnote>. Clearly, we have to do things differently if we want to work with big data <em>and</em> expressive functions. This will be the rest of this post’s topic, specifically how to use both a lot of data $N\gg1$ and many basis functions $p\gg1$, together.</p> <p><br></p> <h1 id="using-less-points">Using Less Points</h1> <p>Since we saw that the problem with the dual solution is that fact that we need to invert a matrix that is $N\times N$, the simplest solution is simply to choose some number $M&lt;N$ and use $M$ train points instead of all of the $N$ data points, where $M$ is sub-sampled from the original points in some manner<d-footnote>See Rasmussen and Williams §8.3 for more about this, in the context of Gaussian process regression (but the concepts are the same)</d-footnote>. This solution also makes sense since many times, we don’t actually need <em>all</em> of the points in order to train, only a diverse enough set of points.</p> <p>The problem then becomes: how do we choose which points to use?</p> <h2 id="subset-of-data">Subset of Data</h2> <p>Simply choosing a subset of the data and throwing out all of the rest is sometimes called the <em>subset of data method</em> (SDM). The easiest way to do this is to randomly choose the subset of size $M$ from all of the points, but this has some obvious drawbacks. This protocol is the one used in the figure 3 below, for different amounts of data that are kept. As you can see, while using 3% of the data is not very useful, we can still achieve pretty good results with 10% of the data (at least in this example). Because of the $O(N^{3})$ complexity of inverting a matrix, this means that we can save something like 3 orders of magnitude of computation (1000 times faster) with these 10% of samples - that’s pretty good!</p> <p><br></p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_9/rec7_subset_data.png" alt="Visualization of noiseless ridge regression" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 3: Examples of the subset of data method (SDM). Orange dots represent data points that were kept (also known as the active set); the orange line is the approximation learned with the particular active set, while the black, dashed line is the true MMSE prediction. As you can see, in this example $\sim$13% of the data already achieves a pretty good approximation of the true posterior. </div> <p><br></p> <h2 id="subset-of-regressors">Subset of Regressors</h2> <p>Recall that the kernel regression problem we saw is equivalent to:</p> \[\begin{equation} f\left(x\right)=\sum_{i=1}^{N}\alpha_{i}k\left(x_{i},x\right) \end{equation}\] <p>with the prior $\alpha\sim\mathcal{N}\left(0,K^{-1}\right)$, where $K$ is the Gram matrix of the kernel $k\left(\cdot,\cdot\right)$ on the $N$ data points $\{ x_{i}\} _{i=1}^{N}$. However, if we use $M&lt;N$ data points instead of the full data set, we can instead approximate the problem using:</p> \[\begin{equation} \tilde{f}\left(x\right)=\sum_{i=1}^{M}\tilde{\alpha}_{i}k\left(x_{i},x\right) \end{equation}\] <p>where $\tilde{\alpha}\sim\mathcal{N}\left(0,K_{mm}^{-1}\right)$, such that $K_{mm}\in\mathbb{R}^{M\times M}$ is the Gram matrix on the subset of $M$ points. In practice, this means that we will attempt to use standard Bayesian linear regression with basis functions corresponding to the kernels centered around the subset of $M$ points (also called the <em>active set</em>).</p> <p>Assume, without loss of generality, that the first $M$ points are those that were chosen and define:</p> \[\begin{equation} H=\left(\begin{matrix}-k^{T}\left(x_{1}\right)-\\ \vdots\\ -k^{T}\left(x_{N}\right)- \end{matrix}\right)\in\mathbb{R}^{N\times M} \end{equation}\] <p>as our basis functions, where $k\left(\tilde{x}\right)=\left(k\left(x_{1},\tilde{x}\right),\cdots,k\left(x_{M},\tilde{x}\right)\right)^{T}\in\mathbb{R}^{N}$. The problem we are trying to fit for all $N$ data points can now be rewritten as:</p> \[\begin{equation} y=H\tilde{\alpha}+\eta\qquad\tilde{\alpha}\sim\mathcal{N}\left(0,K_{mm}^{-1}\right) \end{equation}\] <p>which is just the definition of regular linear regression. Using this notation, the posterior will be given by:</p> \[\begin{equation} \alpha\vert \mathcal{D}_{M}\sim\mathcal{N}\left(\left(H^{T}H+\sigma^{2}K_{mm}\right)^{-1}H^{T}y,\;\left(\frac{1}{\sigma^{2}}H^{T}H+K_{mm}\right)^{-1}\right) \end{equation}\] <p>and the MMSE solution will be:</p> \[\begin{equation} \tilde{f}\left(x\right)=k_{m}^{T}\left(x\right)\left(H^{T}H+\sigma^{2}K_{mm}\right)^{-1}H^{T}y \end{equation}\] <p>where:</p> \[k_{m}\left(\tilde{x}\right)=\left(k\left(x_{1},\tilde{x}\right),\cdots,k\left(x_{M},\tilde{x}\right)\right)^{T}\in\mathbb{R}^{M}\] <p>As you can see in the figure below, the MMSE prediction is much more accurate with fewer points than the subset of data method we saw before.</p> <p><br></p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_9/rec7_subset_regressors.png" alt="Visualization of noiseless ridge regression" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 4: Examples of the subset of regressors method (SRM). Blue dots represent the active set; the blue line is the approximation learned with the particular active set, while the black, dashed line is the true MMSE prediction. Using SRM, even the prediction with very few points is already much more accurate than the SDM we saw before. However, notice that the learned variance is incorrect in areas far from the active set. </div> <p><br></p> <p>This is better than what we had before, but has a major drawback. Consider the variance of our prediction for a given data point:</p> \[\begin{equation} \text{var}\left[\tilde{f}\left(x\right)\right]=\sigma^{2}+k_{m}^{T}\left(x\right)\left(\frac{1}{\sigma^{2}}H^{T}H+K_{mm}\right)^{-1} k_{m}\left(x\right) \end{equation}\] <p>Specifically, if the kernel $k\left(x,\tilde{x}\right)$ we are using decays the further $x$ is from $\tilde{x}$, then our predicted variance will decay faster than it should; this is really clear in all of the examples in figure 3, below -10 and above 10. This is obviously a problem that goes against the core Bayesian philosophy that we should <em>know</em> how uncertain we are about our predictions. To mitigate this affect, another option is to let the predicted value be given by:</p> \[\tilde{f}(x\_*)=\sum\_{i=1}^{M}\tilde{\alpha}\_{i}k\left(x\_{i},x\_{*}\right)+\alpha\_{*}k\left(x\_{*},x\_{*}\right)\] <p>which can also be solved. Adding the additional $\alpha_{*}$ allows us to fix the predictive variance of the model (but we won’t get into that here).</p> <p>At any rate, now when we fit the parameters $\alpha$, we will take into account all data points, not just a subset of them (even though the problem is defined only on a subset). However, this method is still very sensitive to the choice of the subset chosen to represent all data points, as can be seen in the following figure:</p> <p><br></p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_9/rec7_bad_vs_good_SRM.png" alt="Visualization of noiseless ridge regression" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 5: The quality of these approximations is very dependent on the active set that is chosen. On the left, only points from a specific region are chosen as the active set, which makes it hard to predict everything outside of the region. On the other hand, when the same set size is used more effectively, like on the right, we can get very good predictions. </div> <p><br></p> <h1 id="using-less-features">Using Less Features</h1> <p>The whole point of using kernel regression was that we are suddenly able to use very expressive basis functions, without the cost of inverting the posterior covariance, which will have as many dimensions as there are basis functions. But, in the process, we became reliant on inverting an $N\times N$ matrix, which is infeasible when there are many data points. In the previous section we showed that we don’t really need to use all data points in order to fit our kernel machine, but can we instead use less features<d-footnote>What follows is pretty much one-to-one for what you'll find in <a href="http://gregorygundersen.com/blog/2019/12/23/random-fourier-features/" rel="external nofollow noopener noopener noreferrer" target="_blank">this blog post</a></d-footnote>?</p> <h2 id="approximating-kernels">Approximating Kernels</h2> <p>By Mercer’s theorem, if $k:\mathcal{X}\times\mathcal{X}\rightarrow\mathbb{R}$ is a valid kernel, then there exists a basis function $\varphi:\mathcal{X}\rightarrow\mathcal{V}$ such that:</p> \[\begin{equation} k\left(x,y\right)=\left\langle \varphi\left(x\right),\varphi\left(y\right)\right\rangle _{\mathcal{V}} \end{equation}\] <p>where $\mathcal{V}$ is some vector space and $\left\langle \cdot,\cdot\right\rangle _{\mathcal{V}}$ is the inner product associated with $\mathcal{V}$. If this is the case, then perhaps there exists some map $z:\mathcal{X}\rightarrow\mathbb{R}^{q}$ such that:</p> \[\begin{equation} k\left(x,y\right)=\left\langle \varphi\left(x\right),\varphi\left(y\right)\right\rangle _{\mathcal{V}}\approx z^{T}\left(x\right)z\left(y\right) \end{equation}\] <p>If such a map exists, then we can return to the primal form and use the basis functions defined by $z\left(\cdot\right)$ in order to perform standard Bayesian linear regression.</p> <p>An example of such an approximation can be found through <em>random Fourier features</em> (RFF). In RFF, the basis functions are chosen so that they approximate the Fourier transform of the kernel as best as possible. Specifically, instead of using an infinite number of Fourier coefficients, a finite number is chosen which best represent the Fourier transform of the kernel. This trick can easily for any <em>stationary kernel</em><d-footnote>Well, as long as you know the Fourier transform of the kernel, which is probably not that easy to find sometimes</d-footnote>; that is, any kernel that is only defined by the distance between it’s inputs. An example for such a kernel is the Gaussian RBF kernel I’ve been using this whole post.</p> <details><summary>Approximating the RBF kernel</summary> <p>The following was formalized in the article <a href="http://people.eecs.berkeley.edu/~brecht/papers/07.rah.rec.nips.pdf" rel="external nofollow noopener noopener noreferrer" target="_blank">Random Features for Large-Scale Kernel Machines by Rahimi and Recht</a> from 2007, which I highly recommend you to read.</p> <p>Let’s look at a particular example. Suppose $\omega\sim\mathcal{N}\left(0,I\right)$ and define:</p> \[\begin{equation} \varphi_{\omega}:x\mapsto e^{i\omega^{T}x} \end{equation}\] <p>where $i$ is the imaginary unit. In the complex plane, our usual transpose needs to be switched for the conjugate (because we’re using complex numbers), but otherwise everything is the same. Notice that: \(\begin{align} \mathbb{E}_{\omega}\left[\varphi_{\omega}^{*}\left(x\right)\varphi_{\omega}\left(y\right)\right] &amp; =\mathbb{E}_{\omega}\left[e^{i\omega^{T}x}e^{-i\omega^{T}y}\right]\nonumber \\ &amp; =\mathbb{E}_{\omega}\left[e^{i\omega^{T}\left(x-y\right)}\right]\nonumber \\ &amp; =\intop p\left(\omega\right)e^{i\omega^{T}\left(x-y\right)}d\omega\nonumber \\ &amp; \propto\intop e^{-\frac{1}{2}\vert \omega\vert ^{2}}e^{i\omega^{T}\left(x-y\right)}d\omega\nonumber \\ &amp; =\intop\exp\left[-\frac{1}{2}\left(\vert \omega\vert ^{2}-2i\omega^{T}\left(x-y\right)\right)\right]d\omega\nonumber \\ &amp; =\intop\exp\left[-\frac{1}{2}\left(\vert \omega\vert ^{2}-2i\omega^{T}\left(x-y\right)-\left(x-y\right)^{T}\left(x-y\right)\right)-\frac{1}{2}\left(x-y\right)^{T}\left(x-y\right)\right]d\omega\nonumber \\ &amp; =e^{-\frac{1}{2}\vert x-y\vert ^{2}}\intop\underbrace{\exp\left[-\frac{1}{2}\vert \omega-i\left(x-y\right)\vert ^{2}\right]}_{\text{Gaussian integral}}d\omega\nonumber \\ &amp; \propto e^{-\frac{1}{2}\vert x-y\vert ^{2}} \end{align}\)</p> <p>Amazingly, this very simple, <em>random</em>, mapping $\varphi_{\omega}\left(\cdot\right)$ approximates the RBF kernel!</p> <p>Let’s see how we can use this in practice. Suppose we sample $R$ i.i.d. values for $\omega$ from $\mathcal{N}\left(0,I\right)$, then: \(\begin{align} k\left(x,y\right) &amp; =Ce^{-\frac{1}{2}\vert x-y\vert ^{2}}\\ &amp; \overset{\star}{=}\intop\mathcal{N}\left(\omega\,\vert \,0,I\right)e^{i\omega^{T}\left(x-y\right)}d\omega\\ &amp; =\mathbb{E}_{\omega}\left[e^{i\omega^{T}\left(x-y\right)}\right]\\ &amp; \stackrel{\left(*\right)}{\approx}\frac{1}{R}\sum_{j=1}^{R}e^{i\omega_{j}^{T}\left(x-y\right)}\\ &amp; \stackrel{}{=}\left(\begin{matrix}\frac{1}{\sqrt{R}}\exp\left(i\omega_{1}^{T}x\right)\\ \vdots\\ \frac{1}{\sqrt{R}}\exp\left(i\omega_{R}^{T}x\right) \end{matrix}\right)^{T}\left(\begin{matrix}\frac{1}{\sqrt{R}}\exp\left(i\omega_{1}^{T}y\right)\\ \vdots\\ \frac{1}{\sqrt{R}}\exp\left(i\omega_{R}^{T}y\right) \end{matrix}\right)\\ &amp; \stackrel{\Delta}{=} h^{T}\left(x\right)h\left(y\right) \end{align}\)</p> <p>where the step with the $\star$ is going back through the calculations we did before. We now see that the random mapping $h:\mathbb{R}^{d}\to\mathbb{R}^{R}$ approximates the RBF kernel using a finite number of basis functions, even though the RBF kernel uses an <em>infinite</em> number of basis functions. This is pretty cool - a random mapping behaves similarly to a pretty powerful kernel.</p> <p>At the moment, our approximating basis functions are complex, even though our kernel is not. Looking at the step with the $\left(*\right)$, the term on the right hand side is complex while the one on the left hand side is not. Clearly, since they are (approximately) equal, we can remove the complex part. Using Euler’s formula, this is simple:</p> \[\begin{equation} e^{i\omega^{T}\left(x-y\right)}=\cos\left(\omega^{T}\left(x-y\right)\right)+\cancel{i\sin\left(\omega^{T}\left(x-y\right)\right)} \end{equation}\] <p>Now, using some trigonometry:</p> \[\begin{equation} \cos\left(\omega^{T}x-\omega^{T}y\right)=\cos\left(\omega^{T}x\right)\cos\left(\omega^{T}y\right)+\sin\left(\omega^{T}x\right)\sin\left(\omega^{T}y\right) \end{equation}\] <p>So, we can actually rewrite the basis functions as:</p> <p>\(\begin{equation} h\left(x\right)=\frac{1}{\sqrt{R}}\left(\begin{matrix}\cos\left(\omega_{1}^{T}x\right)\\ \sin\left(\omega_{1}^{T}x\right)\\ \vdots\\ \cos\left(\omega_{R}^{T}x\right)\\ \sin\left(\omega_{R}^{T}x\right) \end{matrix}\right) \end{equation}\) where (again) $\omega_{i}\sim\mathcal{N}\left(0,I\right)$.</p> </details> <p>In practice, the RFF approximations are pretty efficient, where typically only $O\left(\sqrt{N}\right)$ random features are needed (where $N$ is the number of points) to get a very good approximation. For very large data sets, this becomes a very significant factor - for instance, with $N=10^{6}$ points, we would instead need $R=10^{3}$ features to guarantee a very good fit, which is doable. In practice, we can also use less random features and still get a suitable approximation.</p> <p>An example use of RFF can be seen in the following figure:</p> <p><br></p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_9/rec7_RFF.png" alt="Visualization of noiseless ridge regression" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 6: Using random Fourier features (RFF) in order to perform regression. The red line is the approximation learned with the particular active set, while the black, dashed line is the true MMSE prediction. Adding more random features makes the prediction more accurate; it looks like $\sim30$ basis functions are enough, which is $\sim20\%$ of the number of data points. </div> <p><br></p> <h1 id="discussion">Discussion</h1> <p>This was a long post. However, you now hopefully have a better understanding of kernel ridge regression, challenges with this regression, and even ways to get around said challenges.</p> <p>One thing that remains kind of dodgy is that we never explicitly defined a prior over our infinite number of parameters. In fact, is a distribution on an infinite number of parameters even possible? The next post delves into this exact conundrum. We will show that <em>yes</em>, it’s possible to define a distribution on the infinite number of parameters, and it allows us to nicely consider the functional form of the regression.</p> <hr> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/8_kernels/">← Kernels</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/10_gaussian_process/">Gaussian processes →</a></span></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>