<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Gaussian Processes | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content="Going one step further into kernel regression, Gaussian processes allow us to define distributions (i.e. priors) over the predictive functions themselves."> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/BML/10_gaussian_process/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Gaussian Processes",
      "description": "Going one step further into kernel regression, Gaussian processes allow us to define distributions (i.e. priors) over the predictive functions themselves.",
      "published": "March 1, 2024",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Gaussian Processes</h1> <p>Going one step further into kernel regression, Gaussian processes allow us to define distributions (i.e. priors) over the predictive functions themselves.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#priors-over-functions">Priors Over Functions</a></div> <div><a href="#gaussian-processes">Gaussian Processes</a></div> <div><a href="#regression-with-gps">Regression with GPs</a></div> <div><a href="#evidence">Evidence</a></div> <div><a href="#extra-mean-function">Extra - Mean Function</a></div> <div><a href="#discussion">Discussion</a></div> </nav> </d-contents> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/9_kernel_regression/">← Extras in kernel regression</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/11_discriminative_classification/">Discriminative classification →</a></span> <br> <br></p> <blockquote> <p>In the previous posts we considered kernels and how they can be used in the context of Bayesian linear regression or ridge regression. In this post, we will consider a more mathematically rigorous investigation into how the kernels effectively define a distribution over functions.</p> </blockquote> <p><br></p> <h1 id="priors-over-functions">Priors Over Functions</h1> <p>Once we moved to regression in the domain of kernels, defining a prior on the parameters makes no sense. In the first place, there might be an infinite number of parameters. Moreover, the regression is defined over the learned functions, not a set of parameters. Finally, it’s simply hard to understand what the effects of the prior will be in the space of parameters, since there’s so many of them.</p> <p>Instead, we will attempt to move from distributions <em>over parameters</em> to a distribution <em>over functions</em>, more rigorously influencing our choices instead of simply saying “we can exchange basis functions with kernels”.</p> <h3 id="distributions-on-functions">Distributions On Functions</h3> <p>Having defined this goal, we immediately have a problem (of course). What does it mean to define a density on <em>a function</em>? A function is like taking random vectors to the extreme. Instead of having a finite set of elements in the vector, we have a continuum of elements. There is no way to define a distribution with full support on such a space directly.</p> <p>But we still might want to prioritize certain types of functions over others. For instance, we could sat that “smooth functions” are more likely than “jagged functions”, in some sense. Such definitions of which functions are more or less likely directly correspond to the behavior of neighboring inputs and outputs. That is, saying a function is usually smooth means that for an input $x$ and its’ neighbor $x+\epsilon$, the outputs should be quite similar, i.e. $f(x)\approx f(x+\epsilon)$. This is a concrete criterion for which functions we are more likely to see.</p> <p>So instead of trying to define a distribution over the space of functions, we will try to say how their outputs are related to each other.</p> <h3 id="stochastic-processes">Stochastic Processes</h3> <p>A stochastic process is the realization of the properties mentioned above. Instead of defining a probability directly on the function, $p(f)$, stochastic processes explain how we should expect a <em>finite set of outputs</em> to be jointly distributed.</p> <p>So, for a finite set of points $x_1,\cdots,x_N$, a stochastic process instead compares the joint distribution:</p> \[\begin{equation} p(f(x_1),\cdots,f(x_N)) \end{equation}\] <p>If this is define for <em>any finite set of points</em>, then we implicitly have a distribution over functions. After all, we typically think of functions as a mathematical object which receives an input and returns an output.</p> <p>In this post, we will consider a specific example of this concept.</p> <p><br></p> <h1 id="gaussian-processes">Gaussian Processes</h1> <h4 id="definition-gaussian-process">Definition: Gaussian Process</h4> <blockquote> <p>A Gaussian Process (GP) is a, possibly infinite, collection of random variables, any finite number of which have a joint Gaussian distribution</p> </blockquote> <p>Equivalently, we will say that $f$ is a Gaussian process:</p> \[\begin{equation} f\left(x\right)\sim\mathcal{GP}\left(m\left(x\right),k\left(x,x'\right)\right) \end{equation}\] <p>with some mean function $m:\mathbb{R}^{d}\rightarrow\mathbb{R}$ and covariance kernel function $k:\mathbb{R}^{d}\times\mathbb{R}^{d}\rightarrow\mathbb{R}$ if for any finite set of points $x_1,\cdots,x_N$ the outputs $f=\left(f\left(x_{1}\right),\cdots,f\left(x_{N}\right)\right)^{T}$ have a Gaussian distribution given by:</p> \[\begin{equation} f\sim\mathcal{N}\left(\mu,C\right) \end{equation}\] <p>where $C_{ij}=k\left(x_{i},x_{j}\right)$ and $\mu_{i}=m\left(x_{i}\right)$.</p> <details><summary>Bayesian linear regression as a GP</summary> <p>A very simple example of a GP is Bayesian linear regression $f\left(x\right)=h\left(x\right)^{T}\theta$ with $\theta\sim\mathcal{N}\left(0,\Sigma_\theta\right)$. The mean of $f$ with respect to $\theta$ is given by:</p> \[\begin{equation} \mathbb{E}\left[f\left(x\right)\right]=\mathbb{E}\left[h^{T}\left(x\right)\theta\right]=h^{T}\left(x\right)\mathbb{E}\left[\theta\right]=0 \end{equation}\] <p>and the covariance:</p> \[\begin{equation} \text{cov}\left[f\left(x\right)\right]=h^{T}\left(x\right)\text{cov}[\theta]h\left(x\right)=h^{T}\left(x\right)\Sigma_{\theta}h\left(x\right) \end{equation}\] <p>So if the prior $\theta$ is Gaussian, then $f\left(\cdot\right)$ is also a Gaussian distribution for any finite set of points, which is exactly the definition of a GP. The GP defined by Bayesian linear regression with a Gaussian prior is:</p> \[\begin{equation} f\left(x\right)\sim\mathcal{GP}\left(0,h^{T}\left(x\right)C_{\theta}h\left(x'\right)\right) \end{equation}\] </details> <p><br></p> <h1 id="regression-with-gps">Regression with GPs</h1> <h2 id="predictions-with-exact-observations">Predictions with Exact Observations</h2> <p>Before moving on to the more general task of predicting new values when we know that our training has some added sample noise, let’s look at the noiseless version. Suppose that we have, as our training set, the pairs $\{ x_{i},f(x_{i})\}_{i=1}^{N}\stackrel{\Delta}{=}\{ x_{i},f_{i}\}_{i=1}^{N}$ and we get a new point $x_{*}$. We want to predict the value of $f\left(x_{*}\right)\stackrel{\Delta}{=} f_{*}$ given the training set $\left{ x_{i},f_{i}\right}_{i=1}^{N}$.</p> <p>Notice that, directly from the definition of a Gaussian process, we know that the finite set of points $f_{1},f_{2},\ldots,f_{N},f_{*}$ are jointly a Gaussian distribution given by:</p> \[\begin{equation} \left[\begin{array}{c} f\\ f_{*} \end{array}\right]\vert\left\{ x_{i}\right\} ,x_{*}\sim\mathcal{N}\left(0,\left[\begin{array}{cc} K &amp; k_{*}\\ k_{*}^{T} &amp; \quad k\left(x_{*},x_{*}\right) \end{array}\right]\right) \end{equation}\] <p>where $k_{*}\stackrel{\Delta}{=}\left(k\left(x_{1},x_{*}\right),k\left(x_{2},x_{*}\right),\ldots,k\left(x_{N},x_{*}\right)\right)^{T}$. Let’s define $\kappa\stackrel{\Delta}{=} k\left(x_{*},x_{*}\right)$ and from now on we will stop conditioning on the observed $x$s. $f_{*}\vert f$ is simply the conditional of a Gaussian distribution, something we’ve already seen multiple times:</p> \[\begin{equation} f_{*}\vert f\sim\mathcal{N}\left({k_{*}^{T}K^{-1}f,\ \ \;\kappa-k_{*}^{T}K^{-1}k_{*}}\right) \end{equation}\] <p>Note that $K$ <em>must</em> be PD for any finite set of points $X$ in order for the above solution to exist. Since $K$ is the Gram matrix of $k\left(\cdot,\cdot\right)$ on the points $X$, then we are restricted to only using PD kernels in the noise-free version of the GP regression. Finding PD kernels may be extremely non-trivial, however the Gaussian kernel we’ve seen and talked about before \emph{is} PD.</p> <h2 id="predictions-with-sample-noise">Predictions with Sample Noise</h2> <p>In the real world, we rarely have noise-free observations. Instead, what we observe is actually:</p> \[\begin{equation} y_{i}=f\left(x_{i}\right)+\eta_{i} \end{equation}\] <p>where $\eta_{i}\sim\mathcal{N}\left(0,\ \sigma^{2}\right)$ and $f$ is a GP. In this case, the covariance of 2 samples $y_{i}$ and $y_{j}$ will be:</p> \[\begin{align} \text{cov}\left[y_{i},y_{j}\right] &amp; =\text{cov}\left[f\left(x_{i}\right)+\eta_{i},f\left(x_{j}\right)+\eta_{j}\right]=k\left(x_{i},x_{j}\right)+\sigma^{2}\cdot\mathbb{I}\left[i=j\right]\\ &amp; \stackrel{\Delta}{=} k\left(x_{i},x_{j}\right)+\sigma^{2}\delta_{ij} \end{align}\] <p>where $\delta_{ij}=1$ if $i=j$ and 0 otherwise. The full covariance matrix of the vector $y=\left(y_{1},y_{2},\ldots,y_{N}\right)^{T}$ is then given by:</p> \[\begin{equation} \text{cov}\left[y\right]=K+\sigma^{2}I \end{equation}\] <p>The joint probability of $y$ with the new point $f_{*}$ is now:</p> \[\begin{equation} \left[\begin{array}{c} y\\ f_{*} \end{array}\right]\sim\mathcal{N}\left(0,\left[\begin{array}{cc} K+\sigma^{2}I &amp; k_{*}\\ k_{*}^{T} &amp; \quad k\left(x_{*},x_{*}\right) \end{array}\right]\right) \end{equation}\] <p>Notice that we didn’t add the sample noise to $k\left(x_{*},x_{*}\right)$ - this is because we want to predict the true underlying value, without adding noise to our prediction. Once again, this is a Gaussian distribution, so we already know how to find the conditional distribution of $f_{*}$:</p> \[\begin{equation} f_{*}\vert y\sim\mathcal{N}\left(k_{*}^{T}\left(K+\sigma^{2}I\right)^{-1}y,\ \ \;\kappa-k_{*}^{T}\left(K+\sigma^{2}I\right)^{-1}k_{*}\right) \end{equation}\] <p>Since the above is Gaussian, the MMSE and MAP solutions are:</p> \[\begin{equation} f_{MMSE}\left(x_{*}\right)=y^{T}\left(K+\sigma^{2}I\right)^{-1}k_{*} \end{equation}\] <h2 id="multiple-inputs">Multiple Inputs</h2> <p>Suppose we want to predict the responses to $m$ new data points, not just 1. In this case, the conditional distribution will be a multivariate Gaussian. If the new points are $Z=\{z_{i}\}_{i=1}^{m}$, then we want to calculate the probability $f_Z\vert y$ where $f_{Z}=\left(f\left(z_{1}\right),f\left(z_{2}\right),\ldots,f\left(z_{m}\right)\right)^{T}$. The joint probability is, once again, Gaussian:</p> \[\begin{equation} \left[\begin{array}{c} y\\ f_{Z} \end{array}\right]\sim\mathcal{N}\left(0,\left[\begin{array}{cc} K+\sigma^{2}I &amp; C\\ C^{T} &amp; \quad K_{Z} \end{array}\right]\right) \end{equation}\] <p>where $C\in\mathbb{R}^{N\times m}$ is a matrix with the indexes $C_{ij}=k\left(x_{i},z_{j}\right)$ and the matrix $K_{Z}\in\mathbb{R}^{m\times m}$ is the Gram matrix for the samples in $Z$. The conditional distribution will be:</p> \[\begin{equation} f_{Z}|y\sim\mathcal{N}\left(C^{T}\left(K+\sigma^{2}I\right)^{-1}y,\ \ \;K_{Z}-C^{T}\left(K+\sigma^{2}I\right)^{-1}C\right) \end{equation}\] <p>Notice that for multiple outputs, all of the outputs are dependent on each other as well! This is a consequence of our definition of GPs, but still, it’s something to remember. The MMSE/MAP is then given by:</p> \[\begin{equation} f_{Z}=C^{T}\alpha \end{equation}\] <p>with the same $\alpha$ as before.</p> <details><summary>Sample noise as part of the kernel</summary> <p>Notice that the noisy version is equivalent to the noise-free version, only we use the kernel:</p> \[\begin{equation} \tilde{k}\left(x,y\right)=k\left(x,y\right)+\sigma^{2}\delta\left(y-x\right) \end{equation}\] <p>instead of $k\left(\cdot,\cdot\right)$. In this variation, as long as we assume that there is some sample noise, we are free to use PSD kernels for $k\left(\cdot,\cdot\right)$, since $\tilde{k}\left(\cdot,\cdot\right)$ will always be PD.</p> <p>The easiest way to see this is by using the definition of PD matrices directly:</p> \[\begin{align*} \forall v\quad v^{T}\left(K+I\sigma^{2}\right)v &amp; =\underbrace{v^{T}Kv}_{\ge0}+\sigma^{2}\|v\|^{2}&gt;0 \end{align*}\] <p>So, if $K$ is PSD, then for any $\sigma^{2}&gt;0$, the matrix $K+I\sigma^{2}$ is PD. In other words, if $K$ is the Gram matrix of $k\left(\cdot,\cdot\right)$, then $C+I\sigma^{2}$ will be the Gram matrix of $\tilde{k}\left(\cdot,\cdot\right)$, which will be PD.</p> </details> <p><br></p> <h1 id="evidence">Evidence</h1> <p>The evidence function allowed us to compare between Bayesian linear regression models, which allowed us to choose the model that best explains the training data. We would like to do the same for GPs. We are essentially looking for the marginal $y\vert\varphi$:</p> \[\begin{equation} y=f_{\varphi}+\eta \end{equation}\] <p>where $\varphi$ are the hyperparameters of the kernel that defines the GP, $\eta\sim\mathcal{N}\left(0,\ I\sigma^{2}\right)$ and $f_{\varphi}=\left(f_{\varphi}\left(x_{1}\right),\ldots,f_{\varphi}\left(x_{N}\right)\right)^{T}$. First, we know that this marginal is Gaussian since the joint distribution of $y$ and $f_{\varphi}$ is Gaussian. Since we know that $y\vert\varphi$ is Gaussian, all we need to do is find the expectation and covariance, which will define the Gaussian:</p> \[\begin{equation} \mathbb{E}\left[y\right]=\mathbb{E}\left[f_{\varphi}\right]+\mathbb{E}\left[\eta\right]=0 \end{equation}\] \[\begin{align} \text{cov}\left[y\right] &amp; =\text{cov}\left[f_{\varphi}+\eta\right]\nonumber \\ &amp; =K_{\varphi}+I\sigma^{2} \end{align}\] <p>So we see that:</p> \[\begin{equation} y\vert\varphi\sim\mathcal{N}\left( 0,\ K_{\varphi}+I\sigma^{2}\right) \end{equation}\] <p>Explicitly, the log-evidence is given by:</p> \[\begin{align} \log p\left(y\vert\varphi\right) &amp; =-\frac{1}{2}y^{T}\left(K_{\varphi}+I\sigma^{2}\right)^{-1}y-\frac{1}{2}\log\left|K_{\varphi}+I\sigma^{2}\right|-\frac{N}{2}\log\left(2\pi\right)\\ &amp; =-\frac{1}{2}\underbrace{y^{T}\alpha_{\varphi}}_{\text{term 1}}-\frac{1}{2}\log\underbrace{\left|K_{\varphi}+I\sigma^{2}\right|}_{\text{term 2}}-\text{const} \end{align}\] <p>The two terms in the log-evidence define a tradeoff between fitness (term 1) and simplicity (term 2):</p> <ol> <li>We can think of the matrix $\left(K_{\varphi}+I\sigma^{2}\right)^{-1}$ as a “projection matrix” onto the space defined by the kernel. When projecting $y$ onto this space, we get the vector $\alpha_{\varphi}$. If the inner product $y^{T}\alpha_{\varphi}$ is small, then the two vectors are considered very close in the space defined by the projection matrix $\left(K_{\varphi}+I\sigma^{2}\right)^{-1}$ - that is, the data is well explained by the model. So, a small distance under the metric defined by the kernel matrix is preferred over larger distances, equivalent to the training points already being well explained by the model</li> <li>The determinant $\vert K_{\varphi}+I\sigma^{2}\vert$ is equivalent to the volume in function space that is modeled by the GP. If $\vert K_{\varphi}+I\sigma^{2}\vert$ is large, then the GP “contains a lot of functions”. If it’s small, then it “explain few functions”. So, if we have two GPs and we have to choose between them, we would prefer the model that contains less functions</li> </ol> <p>The above tradeoff is (somewhat) intuitive: we want a GP that describes as few functions as possible, such that our data is still explained by the GP.</p> <h1 id="extra---mean-function">Extra - Mean Function</h1> <p>In all we did above, we completely ignored the mean function $m\left(\cdot\right)$, and instead assumed that it is defined as $m\left(x\right)=0$. However, any mean function can be used in practice.</p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_10/rec8_GPmean.png" alt="Visualization of GP with NN mean" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 1: Fitting a GP with a mean function parametrized by a neural network. On the left is the prior function defined in this manner, while on the right this GP is fitted to a specific data set. Adding the GP allows us to calibrate the uncertainty of the prediction, while still utilizing the power of the network for the mean function. </div> <p>The above figure shows an example where the mean function is defined by some complicated neural network, $m\left(x\right)=\text{NN}_{\psi}\left(x\right)$ where $\psi$ are the parameters of the network. The GP is then defined as:</p> \[\begin{equation} f\sim\mathcal{GP}\left(\text{NN}_{\psi}\left(\cdot\right),\;k\left(\cdot,\cdot\right)\right) \end{equation}\] <p>where $k\left(\cdot,\cdot\right)$ is some kernel of our choosing. Defining the GP in this way, we can think of the neural network as describing the overall behavior while the GP is added on top to fit the residuals, the data not well fit by the network. In fact, if we have the dataset $\mathcal{D}=\left{ \left(x_{i},f\left(x_{i}\right)\right)\right} _{i=1}^{N}$, then we can simply define:</p> \[\begin{equation} y\left(x\right)=f\left(x\right)-\text{NN}_{\psi}\left(x\right) \end{equation}\] <p>and then $y$ can just be modeled as a zero-mean GP:</p> \[\begin{equation} y\sim\mathcal{GP}\left(0,\;k\left(\cdot,\cdot\right)\right) \end{equation}\] <p>Of course, the choice of a neural function as the mean function is arbitrary. We could have chosen <em>any</em> functional form, and the above would be perfectly acceptable. So, if you have some reason to assume that $m\left(\cdot\right)$ has a specific form, then you can think of the added GP as a model for the deviations from the behavior described by $m\left(\cdot\right)$.</p> <p><br></p> <h1 id="discussion">Discussion</h1> <p>On the surface, GPs aren’t that different from the kernel regression we saw in earlier posts. Conceptually, however, there was a bit shift. GPs implicitly define a distribution <em>over functions directly</em>, whilst in kernel regression we always assumed there were some set of parameters behind the scenes. This ties in nicely with the goal of regression. Many times we don’t really care about the parameters, but about the predicting function. GPs do this directly.</p> <p>Many of the posts so far have been to do with regression with a Gaussian. The stage is now set to leave this setting. In the next few posts we will talk about classification. After that, we will return to the world of regression but with more complex priors, which significantly alters the behavior of the solutions and which problems we can solve.</p> <hr> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/9_kernel_regression/">← Extras in kernel regression</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/11_discriminative_classification/">Discriminative classification →</a></span> <br> <br></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>