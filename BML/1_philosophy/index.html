<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>The Bayesian Philosophy | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content="A high-level description of the frequentist and Bayesian approaches, their differences, and some of their shared qualities."> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/BML/1_philosophy/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "The Bayesian Philosophy",
      "description": "A high-level description of the frequentist and Bayesian approaches, their differences, and some of their shared qualities.",
      "published": "October 28, 2022",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>The Bayesian Philosophy</h1> <p>A high-level description of the frequentist and Bayesian approaches, their differences, and some of their shared qualities.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#frequentist-approach">Frequentist Approach</a></div> <ul> <li><a href="#classical-machine-learning">Classical Machine Learning</a></li> <li><a href="#probabilistic-machine-learning">Probabilistic Machine Learning</a></li> </ul> <div><a href="#bayesian-approach">Bayesian Approach</a></div> <ul> <li><a href="#appeal-of-the-bayesian-approach">Appeal of the Bayesian Approach</a></li> <li><a href="#problems-with-the-bayesian-approach">Problems with the Bayesian Approach</a></li> </ul> <div><a href="#connections">Connections</a></div> <div><a href="#discussion">Discussion</a></div> </nav> </d-contents> <div style="text-align:right"> <a href="https://friedmanroy.github.io/BML/2_estimates/">Estimation and Bayes-Optimal Estimators →</a> </div> <p><br> <br></p> <p>Many tasks in statistics and machine learning can be summarized as attempting to extract information from data. Usually, we will assume that we are given a set of data points: \(\begin{equation} \mathcal{D}=\left\{ x_{1},\cdots,x_{N}\right\} \equiv\left\{ x_{i}\right\} _{i=1}^{N} \end{equation}\) which are assumed to have been drawn<d-footnote>We will usually assume that they are drawn independently from each other but from the same distribute.</d-footnote> from some distribution. Our task, then, is to analyze these data points and extract information from them.</p> <p>The driving force of many analyses will be to attempt to find the distribution from which the data points in $\mathcal{D}$ were initially draw. This task is called <em>modeling</em>, and (broadly speaking) there are two methodologies to doing so - the frequentist approach and the Bayesian approach.</p> <p>These two philosophies are often framed as contradictory, but they don’t necessarily have to compete with each other. Many times the frequentist problem can be framed using the Bayesian philosophy and vice versa. Understanding both sides of the argument can help build a stronger foundation and intuition for machine learning in general.</p> <p>In this post, I will attempt to highlight the difference between the approaches, describing the limitations of each of them but also maybe why (philosophically) they are at odds with each other.</p> <p><br></p> <h1 id="frequentist-approach">Frequentist Approach</h1> <p>The frequentist outlook can be further split into two categories - classical and probabilistic. The first outlook is closer to what is regularly taught in intro2ML type classes, while the second is somewhat more structured. The core characteristics of the frequentist philosophy (both probabilistic and not) can be summarized as:</p> <ol> <li>There is some true set of parameters $\theta$ which model the data; $\theta$ is <strong>not</strong> a probabilistic object. $\theta$ is assumed to describe a set of hypotheses<d-footnote>We will think of a hypothesis as a possible process for generating data.</d-footnote>, one of which (we believe) was used to generate the data</li> <li>We collect data points $\mathcal{D}$ from this “true model” and want to <em>estimate</em> $\theta$ from these data points using a loss function $L\left(\mathcal{D};\,\theta\right)$</li> </ol> <hr> <p>All of these definitions tend to be pretty confusing, but hopefully a very simple example will make the meanings behind the terms clearer.</p> <h4 id="example-coin-toss">Example: Coin Toss</h4> <p>Suppose we observe the outcomes of coin tosses, where each data point $x$ is either “heads” (denoted by $H$ ), or “tails” (denoted by $T$ ). Such a dataset will look something like:</p> \[\begin{equation} \mathcal{D}=\left\{H,T,T,H,T,H\right\} \end{equation}\] <p>However, we have cause to believe that heads and tails are not equally likely to come up when tossing this coin. Our class of hypotheses will be that there exists some number $\theta\in[0,1]$ such that the above sequence is created according to the following process:</p> \[\begin{equation} p(x_i=H)=\theta=1-p(x_i=T) \end{equation}\] <p>Given the dataset $\mathcal{D}$ , we are tasked with finding the number $\theta$ in some manner.</p> <p>How should we go about doing this? The frequentist approach suggests defining some loss function $L(\mathcal{D};\ \theta)$ which will act as a criterion for the quality of our choice of $\theta$ , which we will then attempt to minimize.</p> <hr> <p><br></p> <h2 id="classical-machine-learning">Classical Machine Learning</h2> <p>In the most general form, frequentist machine learning requires two objects, as mentioned before: a set of parameters $\theta$ that define a hypothesis class and a loss function $L\left(\mathcal{D};\,\theta\right)$ . Typically, the loss function is chosen in such a way that it is minimized by the wanted outcome, although this can be hard to control in many real life applications.</p> <p>Framing the problem of machine learning in this manner results in a deterministic algorithm, whose correctness is then left to be proven. Examples of such algorithms are <em>decision trees, support vector machines</em> (SVMs) and <em>k-means</em>, whose definition and solution are inherently not probabilistic.</p> <hr> <h4 id="example-coin-toss-again">Example: Coin Toss (again)</h4> <p>Through a simple thought experiment, we can convince ourselves that for any value of $\theta$ , if we look at a dataset of size $N$ and count the number of heads $N_H$ in said dataset, then at the limit of very large $N$ we will usually observe:</p> \[\begin{equation} \frac{N_H}{N}\stackrel{N\rightarrow\infty}{=}\theta \end{equation}\] <p>If this is true, then maybe a loss of the following form makes sense:</p> \[\begin{equation} L(\mathcal{D};\ \theta)=\left\vert\theta-\frac{N_H}{N}\right\vert \end{equation}\] <p>The value of $\theta$ that minimizes this loss is, rather intuitively, $\hat{\theta}=\frac{N_H}{N}$ and so we will say that this is our guess for the value of $\theta$ (which is why I added the $\hat{}$ , to remind us that this isn’t the true value, only our guess). This estimate has the nice property of being correct in the limit of infinite data (if we believe that this is truly the process that generated the data):</p> \[\hat{\theta}\stackrel{N\rightarrow\infty}{=}\theta\] <p>This example is simplified to the point of being cartoonish, but this a very simplified sketch of one method for estimation.</p> <hr> <p><br></p> <h2 id="probabilistic-machine-learning">Probabilistic Machine Learning</h2> <p>This form of frequentist machine learning is slightly more structured, framing the problem probabilistically. In this form, a stochastic model for the generation of the data is assumed. This model has parameters $\theta$ and a distribution attached to these parameters $p\left(\mathcal{D};\,\theta\right)$ which controls how likely it is for us to have observed the data under a specific choice of the parameters $\theta$ . Here, while $\theta$ appears in a density function, it is <em>not a probabilistic object</em>; that is what the semi-colon (the “;” sign) is meant to convey. The solution to this problem is then to find the parameters $\theta$ that created the data points in $\mathcal{D}$ .</p> <p>Many times, the classical and probabilistic views are connected. Many classical algorithms can be reframed in a probabilistic framework and vice versa. However, the probabilistic outlook allows us to explicitly take into account the stochastic nature of the data, which allows for a more careful way to both <em>define</em> and <em>solve</em> problems.</p> <h3 id="maximum-likelihood-estimation">Maximum Likelihood Estimation</h3> <p>One of the most common probabilistic criterions used to estimate the parameters is called the likelihood. Given a data set $\mathcal{D}$ , we define the likelihood as: \(\begin{equation} L\left(\theta\right)\stackrel{\Delta}{=} p\left(\mathcal{D}\;;\theta\right)=\prod_{i=1}^{N}p\left(x_{i}\;;\theta\right) \end{equation}\) Notice, of course, that the likelihood is a function of the parameters $\theta$ . In this definition, we used the fact that the points were drawn <em>i.i.d.</em> from $p\left(\cdot\;;\theta\right)$ in order to multiply their probabilities - if they weren’t drawn independently, we couldn’t have done this!</p> <p>Having defined this criterion, the natural step in order to estimate the parameters $\theta$ is to maximize the likelihood:</p> \[\begin{equation} \hat{\theta}_{ML}\stackrel{\Delta}{=}\arg\max_{\theta}L\left(\theta\right) \end{equation}\] <p>after all, if $\theta$ maximizes the likelihood, it is the most likely set of parameters to describe the distribution<d-footnote>We will actually show a more formal reason to use MLE in the <a href="https://friedmanroy.github.io/BML/2_estimates/">next post about estimation</a>.</d-footnote>. This estimate is called the <em>maximum likelihood estimate</em> (MLE) of the distribution and we will denote it by $\hat{\theta}_{ML}$ (the $\hat{}$ is to remember that it is an estimate and the $_{ML}$ is to remember that it maximizes the likelihood).</p> <p>Also, usually the log-likelihood is maximized instead of the likelihood, defined as: \(\begin{equation} \ell\left(\theta\right)\stackrel{\Delta}{=}\log L\left(\theta\right)=\sum_{i=1}^{N}\log p\left(x_{i}\;;\theta\right) \end{equation}\) The result is the same (since the logarithm is a strictly monotonically increasing function), however this includes maximizing a sum instead of a product, which is usually easier.</p> <hr> <h4 id="example-coin-toss-yes-again">Example: Coin Toss (yes, again)</h4> <p>Coming back to our coin toss example, if we assume that each coin toss is independent of the one that came before it, then the likelihood that we saw $\mathcal{D}$ is given by:</p> \[\begin{align} p(\mathcal{D};\ \theta)&amp;=\prod_i p(x_i;\ \theta)\\ &amp;=\prod_{i:\ x_i=H}p(x_i=H)\prod_{j:\ x_j=T}p(x_i=T)\\ &amp;=\prod_{i:\ x_i=H}\theta\prod_{j:\ x_j=T}(1-\theta)\\ &amp;=\theta^{N_H}\cdot(1-\theta)^{N-N_H} \end{align}\] <p>Taking the log of this expression, we get:</p> \[\begin{equation} \log p(\mathcal{D}; \theta)=N_H\log\theta +\left(N-N_H\right)\log(1-\theta) \end{equation}\] <p>To find that maximum of this log-likelihood, we can differentiate and equate to 0. After a bit of (simple) math, we will get:</p> \[\begin{align} \frac{\partial \log p(\mathcal{D};\theta)}{\partial \theta }&amp;=\frac{N_H}{\theta}-\frac{N-N_H}{1-\theta}\stackrel{!}{=}0\\ \Leftrightarrow N_H(1-\theta) &amp;=(N-N_H)\theta\\ \Leftrightarrow N\theta &amp;=N_H\\ \Leftrightarrow \hat{\theta} &amp;=\frac{N_H}{N} \end{align}\] <p>and, amazingly, we got the same estimator as the previous approach!</p> <hr> <p><br></p> <h1 id="bayesian-approach">Bayesian Approach</h1> <p>The Bayesian philosophy assumes that we have some knowledge about the distribution the points were drawn from ahead of time, i.e. we assume that the parameters themselves have some distribution $p\left(\theta\right)$ . This distribution is usually called the <em>prior distribution</em>, because we assume we have some prior knowledge. This means that there is no single true value for $\theta$ , rather that a distribution of $\theta$s could have given rise to the data. That is, unlike the frequentist view where $\theta$ <em>is by definition not probabilistic</em>, under the Bayesian view we assume that there is some distribution over $\theta$ s.</p> <p>In this new outlook, instead of trying to find the $\theta$ that generated the data, we will try to update our knowledge regarding which values $\theta$ could have had to create the data. We will want to find is the <em>posterior distribution</em> $p\left(\theta\mid\mathcal{D}\right)$ , so called because we update our beliefs <em>after</em> the fact (in Latin “post” means “after”, while “prior” means “before”). Using Bayes’ law, we can describe this using the prior and likelihood distributions: \(\begin{equation} \overbrace{p\left(\theta\mid\mathcal{D}\right)}^{\text{posterior}}=\frac{\overbrace{p\left(\mathcal{D}\mid\theta\right)}^{\text{likelihood}}\overbrace{p\left(\theta\right)}^{\text{prior}}}{p\left(\mathcal{D}\right)}\propto\overbrace{p\left(\mathcal{D}\mid\theta\right)}^{\text{likelihood}}\overbrace{p\left(\theta\right)}^{\text{prior}} \end{equation}\) Usually we assume that the data set is held constant, so $p\left(\mathcal{D}\right)$ does not affect the calculation of the posterior probability, which is why it is usually disregarded (or swallowed up by the $\propto$ sign). The likelihood term here $p\left(\mathcal{D}\mid\theta\right)$ is actually exactly the same as the frequentist likelihood $p\left(\mathcal{D}\;;\theta\right)$ , only now we can properly condition on $\theta$ .</p> <p>As mentioned, the posterior distribution is an updated version of our beliefs, and gives a new distribution over which values of $\theta$ are likely. That said, we can also extract point estimates (single estimates) of $\theta$ from the posterior. For example:</p> <ol> <li>The <em>maximum a-posteriori</em> (MAP) estimate is defined as: \(\hat{\theta}_{MAP}\stackrel{\Delta}{=}\arg\max_{\theta}p\left(\theta\mid\mathcal{D}\right)=\arg\max_{\theta}p\left(\theta\right)p\left(\mathcal{D}\mid\theta\right)\)</li> <li>The <em>minimum mean squared error</em> (MMSE) estimate is defined as: $\hat{\theta}_{MMSE}\stackrel{\Delta}{=}\mathbb{E}\left[\theta\mid\mathcal{D}\right]$ . As the name suggests, the MMSE is the optimal estimator under a mean squared error loss (assuming our prior is correct)</li> </ol> <p>Finally, many times we are not interested in the posterior over parameter values $\theta$ , but actually only care about the predictions. In this case, we can define the <em>posterior predictive distribution</em> (PPD) defined as: \(\begin{equation} p\left(d^{*}\mid\ \mathcal{D}\right)\stackrel{\Delta}{=}\intop p\left(d^{*}\mid\ \theta\right)p\left(\theta\mid\,\mathcal{D}\right)d\theta \end{equation}\) where $d^{*}$ is a newly observed data point.</p> <hr> <h4 id="example-coin-toss-last-time-promise">Example: Coin Toss (last time, promise)</h4> <p>The only real difference in this example from the MLE version is that now we want to weight each outcome by the prior distribution. The prior distribution conveys our beliefs on the outcomes, which is why it is sometimes called a <em>subjective</em> probability.</p> <p>For this example, having heard about this experiment and seeing it conducted many times in the past, my belief is that it is more likely that the coin is a fair coin, i.e. $\theta\approx 1/2$ than otherwise. However, I additionally feel that it is not impossible for the coin to be unfair (in either direction), so the prior chosen according to previously experiments I’ve seen in the past is:</p> \[\begin{equation} p(\theta)=\frac{1}{2.5}\cdot\cases{4 &amp; $\theta\in[1/4,3/4]$ \\ 1 &amp; otherwise } \end{equation}\] <p>That is, it is 4 times more likely for $\theta$ to be in the range $[1/4,\ 3/4]$ than outside it. Using this prior and a dataset, we can now calculate the posterior distribution which will effectively act as an updated probability for possible values of $\theta$ .</p> <hr> <p><br></p> <h2 id="appeal-of-the-bayesian-approach">Appeal of the Bayesian Approach</h2> <p>Similarly to probabilistic ML, Bayesian ML allows us to elegantly define our problems and how to solve them. All we need to do is define the likelihood function, our prior, and we have the solution - find the posterior distribution. This counters that of the classical ML approach, where a loss function and algorithm have to be found such that: (a) minimizing the loss gives a solution to the problem and (b) the algorithm actually minimizes the loss.</p> <p>Additionally, the Bayesian approach allows us to inject prior knowledge of the problem in order to generate a solution through the density $p\left(\theta\right)$ . This prior knowledge can be very helpful if not much data has been observed. Finally, under certain circumstances, it can be proved that the Bayesian approach will give the <em>optimal</em> solutions.</p> <h2 id="problems-with-the-bayesian-approach">Problems with the Bayesian Approach</h2> <p>The biggest flaw (and strength!) of Bayesian ML is the prior distribution $p\left(\theta\right)$ . Since the prior can <em>heavily</em> affect the solution, it is imperative that it is chosen to correctly reflect the space of solutions. But many times we have no prior knowledge over solutions; for instance, how can we know what the distribution over the parameters of a neural network should look like? This is a very ambiguous decision that has to be made, and many times it is not obvious how to make it. In practice, this means the prior is often arbitrarily chosen and doesn’t necessarily reflect the distribution over parameters we want.</p> <p>An additional difficulty of Bayesian methods is the actual calculation of the posterior $p\left(\theta\mid\,\mathcal{D}\right)$ . While the learning “algorithm” in Bayesian ML is conceptually straightforward, many times the posterior is intractable. In which case approximations or point estimates must be used. These approximations, many times, are based on MCMC samples from the posterior or variational methods, whose quality is difficult to verify.</p> <p>However, both of the above flaws are usually shared with methods in classic ML. Typically, the loss used in such methods is heuristically chosen - much like the prior in Bayesian approaches. Further, while it can be shown that the solution is reached when the loss is minimized, it is usually difficult (if not impossible) to show that the algorithm has actually reached a minimum.</p> <p><br></p> <h1 id="connections">Connections</h1> <p>If we assume an uninformative prior over $\theta$ , i.e. all values of $\theta$ are equally probable and the prior doesn’t add any knowledge as to the choice of $\theta$ : \(\begin{equation} p\left(\theta\right)\propto1 \end{equation}\) then in this case the MAP estimate is: \(\begin{align} \hat{\theta}_{MAP} &amp; =\arg\max_{\theta}p\left(\theta\right)p\left(\mathcal{D}\mid\theta\right)\nonumber \\ &amp; =\arg\max_{\theta}p\left(\mathcal{D}\mid\theta\right)\times\text{const}\nonumber \\ &amp; =\arg\max_{\theta}p\left(\mathcal{D}\mid\theta\right)=\hat{\theta}_{ML} \end{align}\) So we see that the frequentist estimate $\hat{\theta}_{ML}$ is a special case of the Bayesian estimate $\hat{\theta}_{MAP}$ !</p> <p>Actually, we did something extremely fishy when we said that $p\left(\theta\right)$ is “uniform” - this isn’t possible in many cases! A uniform probability over all of the real line $\mathbb{R}$ is impossible… so how can we even talk about this so called “uninformative prior”? While this is true, as long as the posterior $p\left(\theta\mid\mathcal{D}\right)$ is well defined, the MAP and MMSE estimates will still exist. In this special case, the frequentist and Bayesian world views collide, and it will be useful to keep this fact in mind.</p> <p><br></p> <h1 id="discussion">Discussion</h1> <p>Having shown the two possible philosophies, frequentist and Bayesian, it is important to keep in mind that both have viable methods and shortcomings. As a consequence, throughout this series of posts we will typically consider both of these approaches together. Usually, the Bayesian approach will <em>augment</em> the frequentist approach, giving us some structured method to inject prior knowledge into our predictions.</p> <p>So far, everything was very abstract and amorphous. Starting with the next post, we’ll go into some more details. Specifically, we will see how (and when) using estimators extracted using the Bayesian approach will typically be optimal. This necessitates the definition of “optimality” in estimators, which we will build using decision theory.</p> <p><br></p> <hr> <div style="text-align:right"> <a href="https://friedmanroy.github.io/BML/2_estimates/">Estimation and Bayes-Optimal Estimators →</a> </div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>