<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Evidence Function | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content="The evidence function (or marginal likielihood) is one of the cornerstones of Bayesian machine learning. This post shows the construction of the evidence and how it can be used in the context of Bayesian linear regression."> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/BML/7_evidence/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Evidence Function",
      "description": "The evidence function (or marginal likielihood) is one of the cornerstones of Bayesian machine learning. This post shows the construction of the evidence and how it can be used in the context of Bayesian linear regression.",
      "published": "October 28, 2022",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Evidence Function</h1> <p>The evidence function (or marginal likielihood) is one of the cornerstones of Bayesian machine learning. This post shows the construction of the evidence and how it can be used in the context of Bayesian linear regression.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#calculating-the-evidence">Calculating the Evidence</a></div> <div><a href="#evidence-in-bayesian-linear-regression">Evidence in Bayesian Linear Regression</a></div> <div><a href="#equivalent-derivation">Equivalent Derivation</a></div> <div><a href="#examples">Examples</a></div> <ul> <li><a href="#choosing-basis-functions">Choosing Basis Functions</a></li> <li><a href="#choosing-the-prior-mean">Choosing the Prior Mean</a></li> </ul> <div><a href="#regarding-calibration">Regarding Calibration</a></div> <ul> <li><a href="#mitigation">Mitigation</a></li> <li><a href="#priors-all-the-way-down">Priors all the Way Down</a></li> </ul> </nav> </d-contents> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/6_equiv_form/">← Equivalent Form</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/8_kernels/">Kernels →</a></span> <br> <br></p> <blockquote> <p>In the previous posts, we defined the problem of (Bayesian) linear regression and found the MLE and posterior for the linear regression parameters. Throughout, we kind of assumed that the basis functions and prior were somehow chosen ahead of time, and didn’t really talk about how to choose which basis functions to use. This is the focus of the current post.</p> </blockquote> <p>As we have previously discussed, there are many possible basis functions $h\left(\cdot\right)$ we can use to fit the linear regression model, and it is not always so simple to determine which set of basis functions is the correct one to use. On one hand, if we use a very expressive set of basis functions (or a very large one) then the model will easily fit the training data but will probably give very inaccurate predictions for unseen data points. On the other hand, if we use a model that is too simplistic, then we will end up missing all of the data points.</p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_6/hypothesis_choosing.png" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 1: an example of the dilemma of choosing which model should be used. In both plots, a linear function and a 9th order polynomial are fitted to the data. In each case, how can we choose which of the basis functions should be used for linear regression? </div> <p>This is exactly the dilemma represented in figure 1; on the left, it is fairly obvious that the straight line should be chosen, although the 9th order polynomial fits the data better. The graph on the right shows exactly the opposite - the 9th order polynomial intuitively looks like it explains the data better than the linear function. However, in both cases the 9th order polynomial has much higher likelihood. So, how can we choose which of the basis functions is a better fit for the data?</p> <p>The <em>evidence function</em><d-footnote>Bishop section 3.4 or <a href="http://www.inference.org.uk/mackay/itprnn/ps/343.355.pdf" rel="external nofollow noopener noopener noreferrer" target="_blank">MacKay's chapter on model selection in "Information Theory, Inference and Learning Algorithms"</a>.</d-footnote> (also called the <em>marginal likelihood</em>, since we marginalize the parameters out of the distribution) is a way for us to intelligently choose which parameterization to use. The idea behind the evidence function is to “integrate out” the specific values of the parameters $\theta$ and to see how probable the data set is under our prior (which basically includes the basis functions, as well). Suppose we have a prior $p\left(\theta\mid \Psi\right)$ that is dependent on some parameters $\Psi$. Then:</p> \[\begin{align} p\left(\mathcal{D}\mid \Psi\right) &amp; =\intop p\left(\mathcal{D},\theta\mid \Psi\right)d\theta\nonumber \\ &amp; =\intop\underbrace{p\left(\mathcal{D}\mid \theta\right)}_{\text{likelihood}}\cdot\underbrace{p\left(\theta\mid \Psi\right)}_{\text{prior}}d\theta \end{align}\] <p>The way it is written at the moment may be a bit confusing. Up until now (and from now on, as well), we wrote the prior as $p\left(\theta\right)$ , but suddenly we’re adding the conditioning on $\Psi$ - why? When we define a prior, we usually have to choose a distribution for the prior. Often, this distribution has (hyper)parameters that define it; for instance, if the prior is a Gaussian, then the parameters are the specific $\mu_{0}$ and $\Sigma_{0}$ we chose. In our new notation $\Psi=\{ \mu_{0},\Sigma_{0}\}$ , and we want to compare between different possible $\Psi$ s.</p> <hr> <h4 id="example-simple-bayesian-linear-regression">Example: Simple Bayesian linear regression</h4> <p>As an example, suppose we assume that:</p> \[\begin{align} y &amp; =\theta x \end{align}\] <p>Furthermore, we assume that we have two priors on $\theta$ given by:</p> \[\begin{align} \theta &amp; \sim\mathcal{N}\left(\mu_{1},\Sigma_{1}\right)\\ \tilde{\theta} &amp; \sim\mathcal{N}\left(\mu_{2},\Sigma_{2}\right) \end{align}\] <p>In other words, we have two competing priors, from which we want to choose only one. We can then calculate:</p> \[\begin{equation} p\left(y\mid \mu_{i},\Sigma_{i}\right)=\intop p\left(y\mid \theta\right)p\left(\theta\mid \mu_{i},\Sigma_{i}\right)d\theta \end{equation}\] <p>for $i\in\{ 1,2\}$ . If we calculate this probability for both $\mu_{1}$ and $\mu_{2}$ , then we will get a value that tells us how likely the training data $y$ is under each of these different assumptions. That is, instead of asking how probable $y$ is under a specific value of $\theta$ (which is just the likelihood), this is like asking how probable $y$ is when averaging out the values of $\theta$ , <em>given a parameterization</em> with $\mu_{i}$ and $\Sigma_{i}$ .</p> <p>Of course, the priors could assume different basis functions, as in:</p> \[\begin{align} f_{1}\left(x\right) &amp; =\theta x\qquad\theta\sim\mathcal{N}\left(\mu_{\theta},\Sigma_{\theta}\right)\\ f_{2}\left(x\right) &amp; =\beta_{0}+\beta_{1}x\qquad\left(\begin{matrix}\beta_{0}\\ \beta_{1} \end{matrix}\right)\sim\mathcal{N}\left(\mu_{\beta},\Sigma_{\beta}\right) \end{align}\] <p>and we want to choose between $\Psi_{\theta}=\{ \mu_{\theta},\Sigma_{\theta}\}$ and $\Psi_{\beta}=\{ \mu_{\beta},\Sigma_{\beta}\}$ . Notice that the basis functions we assume are also compared when we do this, simply since the basis functions are part of the assumptions we made when we chose our prior.</p> <hr> <p><br></p> <h1 id="calculating-the-evidence">Calculating the Evidence</h1> <p>Suppose that our prior is described, as above, by:</p> <p>$$ \begin{equation} \theta\sim p\left(\theta\mid \ \Psi\right) \end{equation}</p> <p>$$ where $\Psi$ are some hyperparameters. We want to find the value of $p\left(\mathcal{D}\mid \ \Psi\right)$ - the evidence for seeing the data under this parameterization $\Psi$ . Recall from Bayes’ law:</p> \[\begin{align} p\left(\theta\mid \ \mathcal{D},\Psi\right) &amp; =\frac{p\left(\theta,\mathcal{D}\mid \Psi\right)}{p\left(\mathcal{D}\mid \Psi\right)}\\ \Leftrightarrow p\left(\mathcal{D}\mid \Psi\right) &amp; =\frac{p\left(\theta,\mathcal{D}\mid \Psi\right)}{p\left(\theta\mid \ \mathcal{D},\Psi\right)}\\ \Leftrightarrow p\left(\mathcal{D}\mid \Psi\right) &amp; =\frac{p\left(\mathcal{D}\mid \theta\right)p\left(\theta\mid \Psi\right)}{p\left(\theta\mid \ \mathcal{D},\Psi\right)} \end{align}\] <p>This is true for <em>every</em> choice of $\theta$ ! A common way to find the evidence function is by plugging $\hat{\theta}_{\text{MAP}}$ into the expression, which gives:</p> \[\begin{equation}\label{eq:general-evidence} \Leftrightarrow p\left(\mathcal{D}\mid \Psi\right)=\frac{p\left(\mathcal{D}\mid \hat{\theta}_{\text{MAP}}\right)p\left(\hat{\theta}_{\text{MAP}}\mid \Psi\right)}{p\left(\hat{\theta}_{\text{MAP}}\mid \ \mathcal{D},\alpha\right)} \end{equation}\] <p>Usually, the numerator is either known or pretty simple to calculate, while the denominator is quite hard to find. When not analytically tractable, the denominator is approximated in some manner in other to find the evidence. Luckily for us, the denominator is easy to calculate in the case of Bayesian linear regression with a Gaussian prior.</p> <p><br></p> <h1 id="evidence-in-bayesian-linear-regression">Evidence in Bayesian Linear Regression</h1> <p>In standard Bayesian linear regression, the posterior is a Gaussian. We can utilize this knowledge to find a more specific formula for the evidence. Notice that:</p> \[\begin{align} p\left(\hat{\theta}_{\text{MAP}}\mid \ y,\Psi\right) &amp; =\max_{\theta}p\left(\theta\mid \ \mathcal{D},\Psi\right)\\ &amp; =\max_{\theta}\frac{1}{\sqrt{\left(2\pi\right)^{d}\mid \Sigma_{\theta\mid \mathcal{D}}\mid }}e^{-\frac{1}{2}\left(\theta-\mu_{\theta\mid \mathcal{D}}\right)^{T}\Sigma_{\theta\mid \mathcal{D}}^{-1}\left(\theta-\mu_{\theta\mid \mathcal{D}}\right)} \end{align}\] <p>This maximum is attained at $\theta=\mu_{\theta\mid \mathcal{D}}$ , where the whole term in the exponent is equal to 1, so we’re left with:</p> \[\begin{equation} p\left(\hat{\theta}_{\text{MAP}}\mid \ y,\Psi\right)=\frac{1}{\sqrt{\left(2\pi\right)^{d}\mid \Sigma_{\theta\mid \mathcal{D}}\mid }} \end{equation}\] <p>Plugging this into equation \eqref{eq:general-evidence}, we have:</p> \[\begin{equation}\label{eq:evidence-function} p\left(y\mid \Psi\right)=\left(2\pi\right)^{d/2}\mid \Sigma_{\theta\mid \mathcal{D}}\mid ^{1/2}p\left(y\mid \hat{\theta}_{\text{MAP}}\right)p\left(\hat{\theta}_{\text{MAP}}\mid \Psi\right) \end{equation}\] <p>But we can be even more specific by plugging in the MAP estimate under a Gaussian prior:</p> \[\begin{equation} p\left(y\mid \mu,\Sigma\right)=\left(2\pi\right)^{d/2}\mid \Sigma_{\theta\mid \mathcal{D}}\mid ^{1/2}\mathcal{N}\left(\mu_{\theta\mid \mathcal{D}}\mid \;\mu,\Sigma\right)\mathcal{N}\left(y\mid \;H\mu_{\theta\mid \mathcal{D}},I\sigma^{2}\right) \end{equation}\] <p><br></p> <h1 id="equivalent-derivation">Equivalent Derivation</h1> <p>The above derivation allows us to calculate the actual value of the evidence quickly, but it may be a bit harder to understand what is going on in this form. An equivalent way to find the evidence is to find $p\left(\mathcal{D}\mid \Psi\right)$ directly, from the definition. Recall that we modeled linear regression according to:</p> \[\begin{equation} y=H\theta+\eta\quad\eta\sim\mathcal{N}\left(0,I\sigma^{2}\right) \end{equation}\] <p>If we marginalize $\theta$ out of the above equation, it will still be an exponent of something that is quadratic in $y$, so it will be a Gaussian. So we just need to find the mean and covariance in order to find the exact form of the Gaussian:</p> \[\begin{align} \mathbb{E}[y] &amp; =\mathbb{E}[H\theta+\eta] \\ &amp; =H\mathbb{E}[\theta]+\mathbb{E}[\eta]\nonumber \\ &amp; =H\mu_0 \end{align}\] <p>The expectation is always the easiest part, but in this case the covariance isn’t much harder to find: \(\begin{align} \text{cov}[y]&amp;=\text{cov}[H\theta+\eta]\\&amp;=\text{cov}[H\theta]+\text{cov}[\eta]\\&amp;=H\text{cov}[\theta]H^T+I\sigma^2\\&amp;=H\Sigma_0H^T+I\sigma^2 \end{align}\)</p> <p>So, the evidence function for Bayesian linear regression is actually the density of the following Gaussian at the point $y$ :</p> \[\begin{equation} p\left(y\mid \mu_0,\Sigma_0\right)=\mathcal{N}\left(y\,\mid \,H\mu_0,\;H\Sigma_0 H^{T}+I\sigma^{2}\right) \end{equation}\] <hr> <h4 id="example-learning-the-sample-noise">Example: Learning the sample noise</h4> <p>Notice that all this time we assumed that we know the variance of the sample noise, $\sigma^{2}$ . This really helps simplify many of the derivations we made, but is kind of a weird assumption to make.</p> <p>We can try to use a fully Bayesian approach, where we choose a prior for $\sigma^{2}$ and then calculate the posterior. If we try to choose a Gaussian as a prior, we quickly run into a problem - $\sigma^{2}$ can’t be negative, but every Gaussian will have a positive density at negative values! In addition, the Gaussian distribution is symmetric, but the distribution we want to describe $\sigma^{2}$ with is probably very asymmetrical, with low density at values close to zero, high density later on, and a long tail for higher values. So, clearly we can’t use a Gaussian as the prior for $\sigma^{2}$ . There are distributions that match the above description, but we haven’t discussed them (and won’t). Also, finding their posterior is usually a bit harder than finding the posterior of a Gaussian distribution<d-footnote>If you are curious, you can look at Bishop section 2.3.6 for a full derivation of the posterior under a proper prior.</d-footnote>. So, going fully Bayesian is more complicated in this case.</p> <p>Instead, we can use the evidence function in order to choose the most fitting sample noise. In the notation above, we only wrote $y$ as a function of $\mu$ and $\Sigma$ , but it is obviously affected by $\sigma^{2}$ through the covariance:</p> \[\begin{equation} \text{cov}[y]=H\Sigma_0 H^{T}+I\sigma^{2} \end{equation}\] <p>We can define the evidence as a function of the variance as well and then choose from a closed set of values chosen ahead of time $S=\{ \sigma_{i}^{2}\}_{i=1}^{q}$ , in which case we would say:</p> \[\begin{equation} \hat{\sigma}^{2}=\arg\max_{\sigma^{2}\in S}\mathcal{N}\left(y\,\mid \,H\mu_0,\;H\Sigma_0 H^{T}+I\sigma^{2}\right) \end{equation}\] <p>Another option is to use gradient ascent (or another optimization algorithm) in order to find the maximum iteratively:</p> \[\begin{equation} \hat{\sigma}_{\left(t\right)}^{2}=\hat{\sigma}_{\left(t-1\right)}^{2}+\epsilon\nabla_{\sigma}\log p\left(y\,\mid \,\mu_0,\Sigma_0,\sigma\right) \end{equation}\] <p>where $\epsilon$ is some learning rate. However, note that there is no guarantee that the evidence is a concave function!</p> <hr> <p><br></p> <h1 id="examples">Examples</h1> <p>The way evidence is presented is usually not very intuitive. Let’s look at the definition of the evidence for a second:</p> \[\begin{equation} p(\mathcal{D}\mid \Psi)=\intop p(\mathcal{D}\mid \theta) p(\theta\mid \Psi)d\theta =\mathbb{E}_{\theta\mid \Psi}\left[p(\mathcal{D}\mid \theta)\right] \end{equation}\] <p>This is the most direct (and intractable) way to define the evidence, but is a bit more approachable, in an abstract kind of way. Notice that the operation we actually have here is (basically) a sum of all possible likelihoods the data gets under different values of $\theta$ according to the prior (the $p(\mathcal{D}\mid \theta)$ ), weighted by the prior probability. This means that if the data has high likelihood under values of the prior that have high density, then the evidence for the prior will be high. On the other hand, if the area with highest density on the prior isn’t even close to the data, then the evidence will be low. This is shown in the figure below<d-footnote>The way the prior is displayed in these plots is by calculating the mean and standard deviations of $\mathcal{N}\left(H\mu_0,\ H\Sigma_0 H^T + I\sigma^2\right)$ for every point in space, which is exactly like using the equivalent definition of the evidence.</d-footnote>.</p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_6/evidence_fig.png" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 2: a graphical plot for two models - one with high evidence, and one with low evidence. The red dots are the observed data points, which are the same in both plots. The gray contour lines represent the prior's density over possible functions while the black line is the mean of the prior. The left plot is an example of a prior that explains the data well; most data points fall on a high density function according to the prior. On the right, by contrast, the prior gives very low density to the function that created the data, so the the evidence is much worse. </div> <h4 id="choosing-basis-functions">Choosing Basis Functions</h4> <p>Evidence can be used to decide which basis function to use. At the beginning of this post, I showed an example with two polynomials.</p> <p>Below, I show the same as figure 2, just for Gaussian basis functions which are defined according to:</p> <p>\(\begin{equation} h_i(x)=e^{-\frac{\mid \mid x-\mu_i\mid \mid ^2}{2\beta}} \end{equation}\) for some fixed $\beta$ :</p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_6/rbf_evidence_unsymm.gif" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 3: a visualization of the evidence for many different choices of $\mu_1$ and $\mu_2$ . On the left, the red dots are the data points while the gray area and black line are the prior density. On the right is the contour plot of the evidence for pairs of values $(\mu_1, \mu_2)$ - the black dot defines which value of both to display on the left. The white number under the moving dot is the log-evidence for that specific point in parameter-space. </div> <p>The chosen prior for this example is:</p> <p>\(\begin{equation} \theta\sim\mathcal{N}\left(\left[\matrix{a\\-a}\right],\ I\alpha^2\right) \end{equation}\) for some value of $a$ and $\alpha$ .</p> <p>Note that while the evidence space looks symmetric, it isn’t exactly so. The evidence for the lower-right corner is slightly higher than that of the upper-right corner. The reason for this is because of the choice of prior, since the defined function is:</p> \[\begin{equation} f_\theta(x)=\theta_1 h_1(x)+ \theta_2h_2(x)+\eta \end{equation}\] <h4 id="choosing-the-prior-mean">Choosing the Prior Mean</h4> <p>Evidence can also be used to choose which prior is suitable. For instance, suppose that our prior is given by:</p> <p>\(\begin{equation} \left(\matrix{\theta_0\\ \theta_1}\right)\sim \mathcal{N}\left(\left(\matrix{\mathbb{E}[\theta_0]\\ \mathbb{E}[\theta_1]}\right),\ \ I\alpha^2\right) \end{equation}\) where the function is modeled as $f_\theta(x)=\theta_0 + \theta_1 x+\eta$ . The animation below depicts how the evidence changes when the means $\mathbb{E}[\theta_i]$ are changed:</p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_6/lin_evidence.gif" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 4: the same as the previous visualization, only for linear functions. In this animation, the size of the dot corresponds to the sample-specific likelihood; notice how all points are large at the maximum evidence. </div> <p><br></p> <h1 id="maximizing-evidence-as-hypothesis-selection">Maximizing Evidence as Hypothesis Selection</h1> <p>Back in the <a href="https://friedmanroy.github.io/BML/2_estimates/">post about Bayesian decision theory</a>, I introduced which estimators are considered optimal under specific losses and risks. One particular example, actually related to evidence, was that of the 0-1 loss. To jog your memory, in that post we said that if our loss is the same for every wrong example, no matter how far, then the best possible estimator is the MAP estimate. In this sense, if we have to put all our eggs in one basket, the MAP estimator is the way to go.</p> <p>Choosing the linear regression model and set of basis functions to use is an example of this “putting all our eggs in one basket” scenario. Let’s bunch together the basis functions, prior and noise and call all of these things together a <em>hypothesis</em>. Now suppose we have a set of hypothesis:</p> \[\begin{equation} \mathcal{H}=\left\{\Psi_i \right\}_{i=1}^{M} \end{equation}\] <p>We now have to choose one of these hypothesis - only one. It’s kind of hard to say “how wrong” a hypothesis is, after all we started this whole debating by saying that the likelihood for a set of points isn’t a good way to choose a model (at the start of the post). Instead, we just want the one that will be closest.</p> <p>I’m going to assume that all hypothesis are equally as likely, so $p(\Psi_i)=p(\Psi_j)=1/\vert\mathcal{H}\vert$. Then, the MAP estimate under this “hyperprior” over $\mathcal{H}$, given the observed $\mathcal{D}$, is:</p> \[\begin{equation} \hat{\Psi}=\arg\max_{\Psi\in\mathcal{H}}p\left(\Psi\right)p\left(\mathcal{D}\vert\Psi\right)=\arg\max_{\Psi\in\mathcal{H}}p\left(\mathcal{D}\vert\Psi\right) \end{equation}\] <p>This is exactly the setting we’ve been discussing this whole post.</p> <h2 id="regarding-calibration">Regarding Calibration</h2> <p>The evidence is certainly a useful tool for model selection, but it should be used carefully. In particular, relying too much on the evidence without taking care can result in overfitting to the training data. More concisely, high evidence doesn’t equal good generalization! This is because, by design, the marginal likelihood gives high scores to priors which explain the data well.</p> <p>This is really problematic if we don’t take care to separate the manner in which we choose the prior from the model selection stage. For instance, assume we have some data $\mathcal{D}$ and want to find the model that gives this data the highest possible evidence. Recall that:</p> <p>\(\begin{equation} p\left(y\mid \Psi\right)=\mathcal{N}\left(y\,\mid \,H\mu_0,\;H\Sigma_0 H^{T}+I\sigma^{2}\right) \end{equation}\) In such a case, we can <strong>always</strong> define the basis functions/prior such that $H\mu_0=y$ , $\Sigma_0=0$ and $\sigma^2$ is arbitrarily small. This will result in the following, not very helpful, evidence:</p> \[\begin{equation} p\left(\tilde{y}\mid \Psi\right)=\delta(y) \end{equation}\] <p>which is equal to infinity when $\tilde{y}=y$ , a really good evidence score. However, this is obviously not the model we would want to choose! Such a model will not generalize to any new data, which is basically the definition of overfitting.</p> <p>While the above is kind of a silly case we won’t see in real life, it still illustrates the problems that may arise when optimizing the evidence. Specifically, if the set of possible models contains many very specific and expressive models, then optimizing on this set of models is prone to overfitting. On the other hand, it could be tempting to iterate over different sets of possible models as we see the results; again, this would just lead to models that are overfit and won’t be calibrated towards new (unseen) data points.</p> <h2 id="mitigation">Mitigation</h2> <p>This overfitting problem seems to break the proof we had that choosing according to evidence is optimal, right? However, notice that when we have an infinite number of hypothesis to choose from, all of which we give the same probability, we’ve already infringed on the assumptions we made in the previous section. Where did we go wrong? There is no uniform distribution on a set with an infinite number of members!</p> <p>Instead, the discussion above is kind of backwards of how we defined the fitting process in the first place; we assumed that we have several priors that (we believe) explain the data equally well, <em>and only then</em> do we want to select one out of these possible priors. In other words, choosing according to evidence should be carried out only if we remain true to the original Bayesian method and choose a set of priors <strong>before we ever see the data</strong>. Only then should we try to select one of them, so that the selection of the possible set of priors is independent of the data. This, as mentioned, is more in line with the Bayesian philosophy.</p> <h2 id="priors-all-the-way-down">Priors all the Way Down</h2> <p>Probably the “true Bayesian method” to overcome these problems is a different approach all together. In the first place, assuming that all these sets of hypotheses we were talking about are equally likely is questionable. Instead, we would want to choose some sort of <em>hyperprior</em> - a prior over the hyperparameters:</p> \[\psi\sim p(\Psi\mid \xi)\] <p>where $\xi$ are the parameters of the hyperprior.</p> <p>In such a setting, our posterior distribution will be defined by <em>integrating out</em> the hyperparameters:</p> \[p(\theta\mid \mathcal{D})=\intop p(\theta\mid \Psi,\mathcal{D})p(\Psi\mid \xi)d\Psi\] <p>This is nice since it bypasses the need to choose a model - simply integrate over all of them, a more Bayesian approach. It also incorporates our beliefs explicitly - in the integral above we explicitly assumed that $\Psi$ is independent of $\mathcal{D}$ !</p> <p>That said, we have introduced a new complication; how should $\xi$ be chosen? Continuing with this reasoning, shouldn’t we also incorporate a prior over $\xi$, a so called “hyper-hyperprior”, and so on? While these concerns are valid, the “priors all the way down” kind of approach typically stops at a single hyperprior, since it is far enough from the data term. Also, it becomes way too difficult when there’s more than a single hyperprior. <br></p> <h1 id="discussion">Discussion</h1> <p>Choosing models according to the evidence is a very strong method. In particular, we saw how it can be the optimal method to select which model/prior to use. Actually, showing how to calculate the evidence for linear regression is an extremely useful example - in most cases, calculating the evidence is impossible, but for linear regression there’s a closed form for it!</p> <p>Something we haven’t fully explored yet is what happens when we have <em>more parameters than data points</em>, something completely illegal in “classical” machine learning but totally fine under the Bayesian paradigm. Starting in the next post, we’re going to use more parameters - sometimes even infinitely many parameters. <br></p> <hr> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/6_equiv_form/">← Equivalent Form</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/8_kernels/">Kernels →</a></span></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>