<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Kernels and Kernel Regression | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content="The kernel trick allows us to move from regression over a predefined set of basis functions to regression in infinite spaces. All of this is predicated on understanding what a kernel even is and how to construct it. In this post, we will see exactly how to do this and how to use kernels for regression."> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/BML/8_kernels/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Kernels and Kernel Regression",
      "description": "The kernel trick allows us to move from regression over  a predefined set of basis functions to regression in infinite spaces. All of this is predicated on understanding what a kernel even is and how to construct it. In this post, we will see exactly how to do this and how to use kernels for regression.",
      "published": "October 28, 2022",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Kernels and Kernel Regression</h1> <p>The kernel trick allows us to move from regression over a predefined set of basis functions to regression in infinite spaces. All of this is predicated on understanding what a kernel even is and how to construct it. In this post, we will see exactly how to do this and how to use kernels for regression.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#more-parameters-than-data-points">More Parameters than Data Points</a></div> <div><a href="#positive-semi-definite-kernels">Positive Semi-Definite Kernels</a></div> <div><a href="#constructing-kernels">Constructing Kernels</a></div> <div><a href="#rbf-is-a-valid-kernel">RBF is a Valid Kernel</a></div> <div><a href="#frequentist-derivation-of-kernel-regression">Frequentist Derivation of Kernel Regression</a></div> <div><a href="#discussion">Discussion</a></div> </nav> </d-contents> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/7_evidence/">← Evidence Function</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/9_kernel_regression/"> Extras in kernel regression →</a></span> <br> <br></p> <blockquote> <p>Hopefully, by this point you are extremely comfortable with the linear regression problem and it’s Bayesian interpretation. Starting with this post, we are going to explore what happens when, and how we can use, more parameters than data points. This is enabled by the <em>kernel trick</em>.</p> </blockquote> <p>When we introduced linear regression, we allowed the usage of the basis functions $h\left(\cdot\right)$ which mapped the inputs of our problem to features in a different space, allowing us to learn non-linear functions over the input space. This greatly improves the expressiveness of the linear regression model, but is still quite limited as we can only use a finite (and usually small) number of hand-crafted basis functions. We will now look into using more basis functions than data points, and specifically how introducing kernels enables much greater flexibility in the functions the linear regression model can learn.</p> <p><br></p> <h1 id="more-parameters-than-data-points">More Parameters than Data Points</h1> <p>In the classical setting of linear regression, it is typical to hear that “the number of parameters has to be smaller than the number of data points”. However, in the Bayesian framework the number of parameters or data points doesn’t matter all that much. Consider the MMSE function based on some prior $\theta\sim\mathcal{N}\left(\mu_{\theta},\Sigma_{\theta}\right)$:</p> \[\begin{align} f_{\hat{\theta}}\left(x\right) &amp; =h^{T}\left(x\right)\hat{\theta}\\ &amp; =h^{T}\left(x\right)\left(\frac{1}{\sigma^{2}}H^{T}H+\Sigma_{\theta}^{-1}\right)^{-1}\left(\Sigma_{\theta}^{-1}\mu_{\theta}+\frac{1}{\sigma^{2}}H^{T}y\right) \end{align}\] <p>As long as $\Sigma_{\theta}$ is PD, then $\hat{\theta}_{\text{MMSE}}$ always exists. If there aren’t many data points, then the model falls back on the prior for predictions. If there are many data points, then the prior is mostly ignored for predictions. So, in general, the function $h\left(\cdot\right)$ can be as expressive as we want.</p> <p>However, if $h\left(\cdot\right)$ maps to very high dimensions, then we have a different, mostly computational problem. Say $h:\mathbb{R}^{d}\rightarrow\mathbb{R}^{p}$ and $p$ is about a million, then it is infeasible to invert the matrix $H^{T}H+\Sigma_{\theta}^{-1}$ - it will be a huge matrix! To take this to the absurd, if $h\left(\cdot\right)$ is a function that maps to an infinite number of basis functions, what then? It would be helpful if there was a way for us to get past these mostly computational costs.</p> <p><br></p> <h2 id="return-of-the-equivalent-form">Return of the Equivalent Form</h2> <p>Recall that we saw two forms for the MMSE estimate $\hat{\theta}$ that were equivalent. Suppose for a moment that we have a very simple prior $\theta\sim\mathcal{N}\left(0,I\lambda\right)$. Then<d-footnote>See <a href="https://friedmanroy.github.io/BML/6_equiv_form/"> the post about the equivalent form</a> for how to move between the standard and equivalent form</d-footnote>:</p> \[\begin{align} \mu_{\theta|\mathcal{D}} &amp; =\overbrace{\left(\frac{1}{\sigma^{2}}H^{T}H+\frac{1}{\lambda}I\right)^{-1}\frac{1}{\sigma^{2}}H^{T}y}^{\text{standard form}}\\ &amp; =\underbrace{\lambda\cdot H^{T}\left(\lambda HH^{T}+I\sigma^{2}\right)^{-1}y}_{\text{equivalent form}} \end{align}\] <p>Notice that here the matrix we have to invert is dependent on the number of <em>data points</em>, not number of parameters. In fact, the matrix $HH^{T}$ is composed only of inner products of the basis functions between points:</p> \[\begin{equation} HH^{T}=\left[\begin{matrix}h^{T}\left(x_{1}\right)h\left(x_{1}\right) &amp; \cdots &amp; h^{T}\left(x_{1}\right)h\left(x_{N}\right)\\ \vdots\\ h^{T}\left(x_{N}\right)h\left(x_{1}\right) &amp; \cdots &amp; h^{T}\left(x_{N}\right)h\left(x_{N}\right) \end{matrix}\right] \end{equation}\] <p>Let’s try to take advantage of this fact. <br></p> <h2 id="dual-problem">Dual Problem</h2> <p>If we put the definition of the equivalent form instead of the standard form into the MMSE function, we get:</p> \[\begin{equation} f_{\hat{\theta}}\left(x\right)=h^{T}\left(x\right)H^{T}\left(HH^{T}+I\frac{\sigma^{2}}{\lambda}\right)^{-1}y \end{equation}\] <p>Suddenly, everything here is written in terms of the inner products of the basis functions, instead of the outer product, after all:</p> \[\begin{equation} h^{T}\left(x\right)H^{T}=\left[\begin{matrix}h^{T}\left(x\right)h\left(x_{1}\right)\\ \vdots\\ h^{T}\left(x\right)h\left(x_{N}\right) \end{matrix}\right] \end{equation}\] <p>where $x$ is a newly observed point and $x_{1},\cdots,x_{N}$ are our training examples.</p> <p>Let’s define:</p> \[\begin{equation} K=HH^{T}\quad;\quad k\left(x\right)=Hh\left(x\right) \end{equation}\] <p>and rewrite the MMSE function one more time (we’re getting there, I promise):</p> \[\begin{align} f_{\hat{\theta}}\left(x\right) &amp; =k^{T}\left(x\right)\overbrace{\left(K+I\frac{\sigma^{2}}{\lambda}\right)^{-1}y}^{\stackrel{\Delta}{=}\alpha}\\ &amp; \stackrel{\Delta}{=}k^{T}\left(x\right)\hat{\alpha}=f_{\hat{\alpha}}\left(x\right) \end{align}\] <p>This looks a lot like the regular linear regression! Only now, instead of $p$ basis functions with $h:\mathbb{R}^{d}\rightarrow\mathbb{R}^{p}$, we have $N$ basis functions with $k:\mathbb{R}^{d}\rightarrow\mathbb{R}^{N}$. This linear regression problem is called the <em>dual problem</em> to the primal problem that depends on $\theta$.</p> <p><br></p> <h2 id="the-trick">The Trick</h2> <p>So far, we only really manipulated the math into a form which depends on inner products. As is, it seems like a kind of useless exercise in math, since we still always have to calculate the vectors $h\left(x\right)$ anyway. But it turns out we can bypass this evaluation.</p> <p>Suppose that instead of defining the basis functions $h\left(\cdot\right)$ we <em>directly calculate the inner products</em>. That is, instead of defining $h\left(\cdot\right)$, we will define the following function:</p> \[\begin{equation} k\left(x_{i},x_{j}\right)=h^{T}\left(x_{i}\right)h\left(x_{j}\right) \end{equation}\] <p>If such a function $k\left(\cdot,\cdot\right)$ exists, then we won’t ever have to actually calculate the (possibly very large) vectors $h\left(x_{i}\right)$ and will only have to calculate a number for each inner product. If $N\ll p$, this silly trick can cut out a lot of needless computations.</p> <p>This trick is called the <em>kernel trick</em> and the dual form of the solution that we saw above (with $\hat{\alpha}$) is called <em>kernel regression</em>.</p> <p><br></p> <h1 id="positive-semi-definite-kernels">Positive Semi-Definite Kernels</h1> <p>Let’s start by actually defining a kernel.</p> <blockquote> <p><strong>Definition: Positive Semi-Definite (PSD) Kernels</strong> A symmetric function $k:X\times X\rightarrow\mathbb{R}$ is called a PSD kernel on the set $X$ if the associated kernel matrix (also known as the Gram matrix) $K_{ij}=k\left(x_{i},x_{j}\right)$ is PSD for any set of distinct points $\left{ x_{i}\right} _{i=1}^{N}\subseteq X$</p> </blockquote> <p>This definition alone already gives us some information on the type of functions that are valid kernels:</p> <blockquote> <p><strong>Claim:</strong> As a by-product, if we have any two functions $g:\mathbb{R}^{m}\times\mathbb{R}^{m}\rightarrow\mathbb{R}$ and $h:\mathbb{R}^{m}\rightarrow\mathbb{R}^{n}$ such that: $g\left(x_{1},x_{2}\right)=h\left(x_{1}\right)^{T}h\left(x_{2}\right)$ then $g\left(\cdot,\cdot\right)$ is a PSD kernel (which we will just call a kernel for now).</p> </blockquote> <h4 id="proof">Proof:</h4> <p>Let’s define:</p> \[\begin{equation} H^{T}=\left[\begin{matrix}-h\left(x_{1}\right)^{T}-\\ -h\left(x_{2}\right)^{T}-\\ \vdots\\ -h\left(x_{n}\right)^{T}- \end{matrix}\right]\in\mathbb{R}^{m\times N} \end{equation}\] <p>where we have $N$ points $x_{1},x_{2},\ldots,x_{N}$. The Gram matrix is defined as:</p> \[\begin{equation} G=H^{T}H\Rightarrow G_{ij}=h\left(x_{i}\right)^{T}h\left(x_{j}\right) \end{equation}\] <p>As we have seen before, any the product of a matrix with it’s transpose is a PSD matrix, which means that $G$ is PSD, which in turn means that $g\left(\cdot,\cdot\right)$ is a kernel. So, for any symmetric function $k\left(\cdot,\cdot\right)$, if we can show that it is the inner product of two vectors, then the function is a kernel. <span style="float:right"> $\square$ </span></p> <p>Now the connection to basis functions should be easy to see - any set of basis functions defines a kernel.</p> <details><summary>Examples</summary> <p>Let’s go over some examples for valid and non-valid kernels. Hopefully this will build a good intuition of whether something is a PSD kernel or not.</p> <ul> <li> <p>$k\left(x,y\right)=c$ where $c&gt;0$ is some constant This is quite obviously <strong>a valid kernel</strong>, since the Gram matrix will be made fully of $c$ s and we have:</p> \[\begin{align*} a^{T}Ka &amp; =a^{T}\left(c\boldsymbol{1}\right)\boldsymbol{1}^{T}a\\ &amp; =\sum_{i}a_{i}c\cdot\sum_{i}a_{i}\\ &amp; =c\sum_{i}a_{i}\sum_{i}a_{i}\\ &amp; =c\left(\sum_{i}a_{i}\right)^{2}\ge0 \end{align*}\] </li> <li> <p>$k\left(x,y\right)=f\left(x\right)^{T}g\left(y\right)$ where $f\left(\cdot\right)\neq g\left(\cdot\right)$ One of the basic definitions of a PSD kernel is that it is <em>symmetric</em>. However, for this function:</p> </li> </ul> <p>\(k\left(x,y\right)=f\left(x\right)^{T}g\left(y\right)\neq f\left(y\right)^{T}g\left(x\right)=k\left(y,x\right)\) so $k\left(\cdot,\cdot\right)$ <strong>is not a valid kernel</strong></p> <ul> <li> <p>$k\left(x,y\right)=\text{cov}[x,y]$ When we build the Gram matrix using this function for any finite set of points, we actually build a covariance matrix, which we have shown is a PSD matrix. So this is <strong>a valid kernel</strong></p> </li> <li> <p>$k\left(x,y\right)=-x^{T}y$ Recall that for a PSD matrix $A$ and any vector $v$ , the following must hold: \(v^{T}Av\ge0\) Now, if we choose the unit vector $e_{i}$ as $v$ , we have: \(e_{i}^{T}Ae_{i}=A_{ii}\) where $e_{i}=\left(0,\ldots,0,\overbrace{1}^{i\text{th index}},0,\ldots,0\right)$ . From this we directly see that for any $i$ , $A_{ii}\ge0$ must hold in order for $A$ to be PSD. In kernels this is equivalent to showing that $k\left(x,x\right)\ge0$ . In the case of this vector, $k\left(x,x\right)&lt;0$ is a very real possibility, so there is no way that the Gram matrix will be PSD, so it is <strong>not a valid kernel</strong></p> </li> </ul> <p><br> Okay, okay, that’s enough examples. From the above there are two rules we can clearly see:</p> <ol> <li>If there exists two vectors $x$ and $y$ such that $k\left(x,y\right)\neq k\left(y,x\right)$ then $k\left(\cdot,\cdot\right)$ is not a valid kernel</li> <li>If there exists a vector $x$ such that $k\left(x,x\right)&lt;0$ then $k\left(\cdot,\cdot\right)$ is not a valid kernel</li> </ol> <p>However, there are some functions that do not violate these two rules but are still not kernels, so we need to be especially careful with how we define our functions and whether they are actually valid kernels or not.</p> </details> <p><br></p> <h1 id="constructing-kernels">Constructing Kernels</h1> <p>We’ve shown that we can think of any set of basis functions as one part of a kernel, but if we always do this then we fall back to the problem of having to pick the set basis functions, instead of choosing the kernel directly. We have also shown that it is kind of a pain to prove if something is a valid kernel or not, in the general case. We will now go on to show how kernels can be constructed directly<d-footnote>The construction of kernels is the same as in Bishop 6.2, although slightly altered</d-footnote>, instead of going through basis functions.</p> <p>Since a kernel is valid as long as the Gram matrix on any set of points is PSD, we can create building blocks, and stack them on top of each other to get more complex kernels. For any two valid kernels $k_{1}\left(\cdot,\cdot\right)$ and $k_{2}\left(\cdot,\cdot\right)$ the following functions will also be kernels:</p> <ol> <li>$c\cdot k_{1}\left(x,y\right)$ where $c&gt;0$ is a constant</li> <li>$f\left(x\right)k_{1}\left(x,y\right)f\left(y\right)$ where $f:\mathbb{R}^{n}\rightarrow\mathbb{R}$</li> <li>$q\left(k_{1}\left(x,y\right)\right)$ where $q\left(\cdot\right)$ is any polynomial with non-negative coefficients</li> <li>$\exp\left(k_{1}\left(x,y\right)\right)$</li> <li>$k_{1}\left(x,y\right)+k_{2}\left(x,y\right)$</li> <li>$k_{1}\left(x,y\right)k_{2}\left(x,y\right)$</li> <li>$k\left(x,y\right)=x^{T}Ay$ where $A$ is PSD</li> </ol> <p>Using these building blocks, we can create more and more complex kernels, as we see fit.</p> <p><br></p> <div class="fake-img l-page"> <p align="center"> <img src="https://friedmanroy.github.io/assets/bml_figs/rec_8/rec6_gram_matrices.png" alt="Visualization of noiseless ridge regression" style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 1: Examples of different Gram matrices for inputs in the linear range [-3, 3]. The left two examples are for Gaussian kernels with different widths, and the right two are the Gram matrices of the linear and quadratic kernels, respectively. In all of these plots, darker colors mean higher values. </div> <p><br></p> <details><summary>Example: Polynomial Kernel</summary> <p>Using the construction blocks, we saw that a polynomial of a kernel with non-negative coefficients is, itself, a valid kernel. Let’s look at the specific case:</p> \[\begin{equation} k\left(x,y\right)=\left(x^{T}y\right)^{2} \end{equation}\] <p>where $x,y\in\mathbb{R}^{2}$ . This is clearly a kernel because claims (3) and (7) are used to construct it. However, we want to understand exactly why this is a valid kernel. This becomes quite clear when we take a closer look at the function:</p> \[\begin{align*} \left(x^{T}y\right)^{2} &amp; =\left(x_{1}y_{1}+x_{2}y_{2}\right)^{2}\\ &amp; =x_{1}^{2}y_{1}^{2}+2x_{1}y_{1}x_{2}y_{2}+x_{2}^{2}y_{2}^{2}\\ &amp; =\left(\begin{matrix}x_{1}^{2} &amp; \sqrt{2}x_{1}x_{2} &amp; x_{2}^{2}\end{matrix}\right)\left(\begin{matrix}y_{1}^{2}\\ \sqrt{2}y_{1}y_{2}\\ y_{2}^{2} \end{matrix}\right)\\ &amp; =p_{2}\left(x\right)^{T}p_{2}\left(y\right) \end{align*}\] <p>So, the kernel is actually the inner product between two basis functions, which in this case happen to be second order polynomials. The function $p_{2}\left(\cdot\right)$ maps a vector $x$ to all possible 2nd order terms, times some constants:</p> <p>\(\left(\begin{matrix}x_{1}^{2} &amp; \sqrt{2}x_{1}x_{2} &amp; x_{2}^{2}\end{matrix}\right)^{T}\) In the same manner, if we would have chosen a kernel of the form $\left(x^{T}y\right)^{m}$ , then it would map from the features into all possible $m$ -th order terms of the features.</p> <p>Now, instead, let’s look at the following:</p> \[\begin{align*} \left(x^{T}y+1\right)^{2} &amp; =\left(x_{1}y_{1}+x_{2}y_{2}+1\right)^{2}\\ &amp; =x_{1}^{2}y_{1}^{2}+x_{2}^{2}y_{2}^{2}+1+2x_{1}y_{1}+2x_{2}y_{2}+2x_{1}y_{1}x_{2}y_{2} \end{align*}\] <p>And we’re not going to even bother writing this in vector form. Notice that now the expression holds all terms <em>up to</em> the 2nd degree. This would also be true for any degree $m$ where $\left(x^{T}y+1\right)^{m}$ would expand all features up to (and including) the $m$ -th degree. It is also really easy to see that this is still a valid kernel, using the claims from earlier. The kernel:</p> \[\begin{equation} k_{m}\left(x,y\right)=\left(x^{T}y+1\right)^{m} \end{equation}\] <p>is called the polynomial kernel exactly because of the characteristics we described.</p> </details> <p><br></p> <h1 id="rbf-is-a-valid-kernel">RBF is a Valid Kernel</h1> <p>A family of basis functions that are often used in practice are the radial basis functions (RBF). The most common function from this family is the Gaussian basis function:</p> \[\begin{equation} h_{\mu}\left(x\right)=\exp\left[-\frac{\left(x-\mu\right)^{2}}{2s^{2}}\right] \end{equation}\] <p>which we have already talked about. However, instead of defining the function’s center ( $\mu$ ), we can define a kernel based on this basis function, that uses the distance between <em>any</em> two points:</p> \[\begin{equation} k\left(x,y\right)=\exp\left[-\frac{1}{2}\left(x-y\right)^{T}A\left(x-y\right)\right] \end{equation}\] <p>where we have broadened our definition by adding $A$ as any PSD matrix. This kernel is very widely used in literature and in practice.</p> <blockquote> <p><strong>Claim:</strong> The Gaussian kernel is a valid kernel</p> </blockquote> <h4 id="proof-1">Proof:</h4> <p>For the proof we will use several of the claims for constructing kernels. We begin (as usual) by expanding the Mahalanobis distance:</p> \[\begin{equation} \left(x-y\right)^{T}A\left(x-y\right)=x^{T}Ax-2x^{T}Ay+y^{T}Ay \end{equation}\] <p>We can now rewrite the function as:</p> \[\begin{align} k\left(x,y\right) &amp; =\exp\left[-\frac{1}{2}x^{T}Ax\right]\exp\left[x^{T}Ay\right]\exp\left[-\frac{1}{2}y^{T}Ay\right]\\ &amp;\stackrel{\Delta}{=}f\left(x\right)\exp\left[\underbrace{x^{T}Ay}_{q\left(x,y\right)}\right]f\left(y\right) \end{align}\] <p>Notice how we brought the form of the whole function as the form in claim (2) (i.e., multiplied by a function on either side). Since $A$ is a PSD matrix, $q\left(x,y\right)$ must also be a valid kernel. Using claim (4), the exponent of a kernel is also a kernel, therefore $k\left(\cdot,\cdot\right)$ is a valid kernel. <span style="float:right"> $\square$ </span></p> <p><br> The Gaussian kernel can actually be rewritten as:</p> \[\begin{align} k\left(x,y\right) &amp; =f\left(x\right)\left(\sum_{n=0}^{\infty}\frac{1}{n!}\left(x^{T}Ay\right)^{n}\right)f\left(y\right)\nonumber \\ &amp; =f\left(x\right)\left(\sum_{n=0}^{\infty}\frac{1}{n!}k_{n}\left(x,Ay\right)\right)f\left(y\right) \end{align}\] <p>where $k_{n}\left(\cdot,\cdot\right)$ is the $n$ -th order polynomial kernel. Remember how we opened up the polynomial kernel into the inner product between two vectors? For this kernel, we would have to build infinitely long vectors, with every polynomial degree in it, and then find the inner product of these two vectors. In this sense, we can think of the kernel as a basis function $h\left(\cdot\right)$ that maps inputs into infinite feature spaces.</p> <p><br></p> <h1 id="frequentist-derivation-of-kernel-regression">Frequentist Derivation of Kernel Regression</h1> <p>We saw how we can manipulate the Bayesian linear regression to the form of kernel regression. But the same can be done in the frequentist framework, starting from ridge regression<d-footnote>Bishop 6.1</d-footnote> (which, as we all know, is just a private case of Bayesian linear regression anyway).</p> <p>First, remember that the loss function for ridge regression is given by:</p> \[\begin{equation} L\left(\theta\right)=\|H\theta-y\|^{2}+\lambda\|\theta\|^{2} \end{equation}\] <p>Deriving this by $\theta$ and equating to 0 we see that:</p> \[\begin{align} 2\frac{\partial}{\partial\theta}L\left(\theta\right) &amp; =-H^{T}H\theta+H^{T}y+\lambda\theta\stackrel{!}{=}0\\ \Rightarrow\theta &amp; =\frac{1}{\lambda}H^{T}\left(H\theta-y\right) \end{align}\] <p>We can now define:</p> \[\begin{align} \theta &amp; =\frac{1}{\lambda}H^{T}\left(H\theta-y\right)=\frac{1}{\lambda}\sum_{i}\overbrace{\left(h\left(x_{i}\right)^{T}\theta-y_{i}\right)}^{\alpha_{i}}h\left(x_{i}\right)\\ &amp; \stackrel{\Delta}{=}\sum_{i}\alpha_{i}h\left(x_{i}\right)\stackrel{\Delta}{=} H^{T}\alpha \end{align}\] <p>So we can rewrite the solution for $\theta$ as a linear function of the functions that make up $H$, where $\alpha_{i}$ is the coefficient for the basis functions over the $i$-th sample $h\left(x_{i}\right)$.</p> <p>The minimum of $L\left(\cdot\right)$ with respect to $\alpha$ is:</p> \[\begin{align*} L\left(\alpha\right) &amp; =\|HH^{T}\alpha-y\|^{2}+\lambda\|H^{T}\alpha\|^{2}\\ \Rightarrow\frac{\partial}{\partial\alpha}L\left(\alpha\right) &amp; =HH^{T}HH^{T}\alpha-HH^{T}y+\lambda HH^{T}\alpha\stackrel{!}{=}0 \end{align*}\] <p>If we assume that $HH^{T}$ is invertible, we get:</p> \[\begin{equation} \hat{\alpha}_{ML}=\left(HH^{T}+I\lambda\right)^{-1}y \end{equation}\] <p>which is very similar to the solution we saw for ridge regression with $\theta$. Now, let’s plug this into the linear regression function:</p> \[\begin{align} f\left(x\right) &amp; =\hat{\theta}_{ML}^{T}h\left(x\right)=\hat{\alpha}_{ML}^{T}Hh\left(x\right)\\ &amp; =y^{T}\left(HH^{T}+I\lambda\right)^{-1}Hh\left(x\right) \end{align}\] <p>Defining the Gram matrix $K=HH^{T}$ such that $K_{ij}=h\left(x_{i}\right)^{T}h\left(x_{j}\right)$ and the vector $k\left(x\right)$ where $k_{i}\left(x\right)=h\left(x\right)^{T}h\left(x_{i}\right)$, then we can rewrite the above as:</p> \[\begin{equation} f\left(x\right)=y^{T}\left(K+I\lambda\right)^{-1}k\left(x\right) \end{equation}\] <p>Suppose that, instead of defining the basis functions $h\left(\cdot\right)$, we define a kernel $k\left(x_{i},x_{j}\right)$. While before it was not so obvious how this would fit into the structure of the linear regression, now all we need to define is $K_{ij}=k\left(x_{i},x_{j}\right)$ and $k_{i}\left(x\right)=k\left(x,x_{i}\right)$ in order to get the prediction for a new point $x$.</p> <p>Now the reason we allow P<strong>S</strong>D and not only PD kernels might be easier to see. Since the matrix we are inverting is $\left(K+I\lambda\right)$, even if the Gram matrix $K$ is not PD (i.e. not invertible) and only PSD, because of the added term $I\lambda$, the whole matrix is PD. Under this reasoning, and because forming PSD kernels is easier than forming PD kernels, we can relax our restrictions on the form of the kernels and use PSD kernels, giving us just a bit more freedom. <br></p> <h1 id="discussion">Discussion</h1> <p>The kernel trick allows us to move from a small number of parameters, to many more parameters than data points even. While classically using more (meaningful) parameters than data points makes no sense, in the Bayesian framework of linear regression, there is no reason <em>not to</em> use many parameters. Because we added a prior of the values of the parameters, the complexity of the results is efficiently mitigated.</p> <p>However, it is still not exactly clear <em>how</em> to use kernels, or what priors over kernels really mean. Moreover, moving from basis functions to kernels actually introduces some difficulties. In the next post we will look into all of these aspects of kernel regression.</p> <p><br></p> <hr> <p><span style="float:left"><a href="https://friedmanroy.github.io/BML/7_evidence/">← Evidence Function</a></span><span style="float:right"><a href="https://friedmanroy.github.io/BML/9_kernel_regression/"> Extras in kernel regression →</a></span></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>