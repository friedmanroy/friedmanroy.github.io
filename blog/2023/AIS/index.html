<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Annealed Importance Sampling | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content=""> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/blog/2023/AIS/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Annealed Importance Sampling",
      "description": "",
      "published": "November 9, 2023",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Annealed Importance Sampling</h1> <p></p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#problem-setting">Problem Setting</a></div> <div><a href="#annealing-the-importance-distribution">Annealing the Importance Distribution</a></div> <div><a href="#importance-weights">Importance Weights</a></div> <div><a href="#finding-your-keys">Finding Your Keys</a></div> <div><a href="#practical-applications-of-ais">Practical Applications of AIS</a></div> <div><a href="#conclusion">Conclusion</a></div> </nav> </d-contents> <p>Suppose you can’t find your keys. You know you left them in your apartment somewhere, but don’t remember where. This happens pretty often, so you have a keep note of the possible places you may have left your keys. You want to find out the probability that the keys are in a specific room of your apartment. Let’s call this room $R$ - mathematically speaking, you want to calculate: \(\begin{equation} P\left(\text{keys}\in R\right)=\intop \mathbf{1}\left[x\in R\right]\cdot p_\text{keys}(x)dx \end{equation}\)</p> <p>where $x\in\mathbb{R}^2$ is a two-dimensional coordinate where the keys may have been forgotten and $p_\text{keys}(x)$ is the PDF for the keys to be in the location $x$. The function $\mathbf{1}\left[x\in R\right]$ equals 1 if $x\in R$, otherwise it is 0. The above can be rewritten:</p> \[\begin{equation} P\left(\text{keys in }R\right) = \mathbb{E}_{x\sim p_\text{keys}}\left[\mathbf{1}\left[x\in R\right]\right] \end{equation}\] <p>So… how can we calculate (or approximate) this expectation? Which room is most probable to contain your lost keys?</p> <p>While this example is a bit silly, the problem can be abstracted to fit many different situations. In this post, I’m going to show how it can be solved using Annealed Importance Sampling (AIS, <d-cite key="AIS"></d-cite>). Honestly speaking, when the data is 2-dimensional there are better ways to do this, but 2D allows for simple (intuitive!) visualizations, so let’s stick with our somewhat wonky example.</p> <p><br></p> <h1 id="problem-statement"><strong>Problem Statement</strong></h1> <d-byline></d-byline> <p>Let’s define the problem again, just a bit more generally.</p> <p>We have some distribution over the domain $\mathcal{X}$: \(\begin{equation} p(x)= \frac{1}{Z}\tilde{p}(x) \end{equation}\)</p> <p>where for a given $x$ we know how to calculate $\tilde{p}(x)$. In this example, I’m going to assume the normalizing constant $Z$ isn’t known. This setting matches a situation where you keep track of where the keys were left in the past and have a non-parametric formulation for the density $\tilde{p}(x)$, in which case $Z$ is hard to calculate.</p> <p>I will also assume that there’s a function $f:\mathcal{X}\rightarrow \mathbb{R}$ and we want (for whatever reason) to calculate:</p> \[\begin{equation}\label{eq:f-exp} \overline{f}=\mathbb{E}_{x\sim p(x)}\left[f\left(x\right)\right] \end{equation}\] <p>In our example, $p(x)=p_\text{keys}(x)$ and $f(x)=\mathbf{1}\left[x\in R\right]$.</p> <p>The question is: how can we calculate $\overline{f}$? And as a secondary goal: is there a way to estimate $Z$ simultaneously, so we have access to the full (normalized) distribution?</p> <h3 id="first-approach">First Approach</h3> <p>One way to find $\overline{f}$ and $Z$ is using <em>importance sampling</em> (IS). In IS, a simple distribution $q(x)$ is chosen and the expectation in equation \eqref{eq:f-exp} is approximated according to (see <a href="#a1-importance-sampling">A.1</a> for more details):</p> \[\begin{equation} \tilde{w}(x)=\frac{\tilde{p}(x)}{q(x)}\qquad\overline{f}\approx \frac{\sum_{x_i\sim q}\tilde{w}(x_i)f(x_i)}{\sum_{x_i\sim q}\tilde{w}(x_i)} \end{equation}\] <p>The number $\tilde{w}(x)$ defines the relative importance of $x$ under our distribution of interest $\tilde{p}(x)$ and the simple distribution $q(x)$, which is why $\tilde{w}(x)$ are called <em>importance weights</em>.</p> <p>IS also let’s us approximate the normalization constant $Z$, using only the importance weights: $Z=\mathbb{E}<em>q\left[\tilde{w}(x)\right]\approx\frac{1}{N}\sum</em>{x_i\sim q}^N\tilde{w}(x_i)$.</p> <p>This seems to solve the problem we defined earlier. Of course, this post is about <em>annealed</em> IS, not IS, so there’s going to be a bit more to read.</p> <p>While incredibly simple and easy to use, IS is actually pretty hard to calibrate. Here, calibration means choosing a distribution $q(x)$ that is similar in some sense to $p(x)$. The best we can do, after all, is $q(x)=p(x)$. In that case, all of the importance weights will be equal to 1 and we would get a perfect approximation of $\overline{f}$ and $Z$. No, usually a much simpler distribution $q(x)$ is chosen, and if $q(x)\gg p(x)$ in some region of space then many samples from $q(x)$ will end up with very low importance weights $\tilde{w}(x)$. In such a situation, an enormous number of samples has to be used in order to get a sound approximation.</p> <h3 id="another-way">Another Way</h3> <p>If we are solely interested in estimating the expectation in equation \eqref{eq:f-exp}, then another alternative is available - as long as we have some method for producing samples from $p(x)$ using only the unnormalized function $\tilde{p}(x)$. If that is the case, then $M$ points $x_1,\cdots,x_M$ can be sampled and used to get an unbiased approximation of the expectation:</p> \[\begin{equation} \overline{f}\approx\frac{1}{M}\sum_{i:\ x_i\sim p}^M f(x_i) \end{equation}\] <p>To this end, Markov chain Monte Carlo (MCMC) methods can be used, such as <a href="https://friedmanroy.github.io/blog/2022/Langevin/">Langevin dynamics</a>, in order to sample from the distribution. Many of these MCMC methods only require access to the gradient of the log of the distribution, $\nabla \log p(x)=\nabla \log \tilde{p}(x)$, so not knowing the normalization constant isn’t a problem. However, this doesn’t give us any estimate of $Z$ and many times it’s also difficult to tune an MCMC sampler.</p> <h3 id="combining-is-with-mcmc">Combining IS with MCMC</h3> <p>At it’s core, AIS is a way to combine the importance weights in IS with an MCMC approach. The idea is relatively simple: start with a sample from a simple distribution $q(x)$ and use MCMC iterations to get this sample closer to the distribution of interest $p(x)$. At the same time, we can also keep track of the relative importance of the sample, getting better calibrated importance weights.</p> <p>That’s the main intuition behind AIS. Don’t worry if it’s still unclear, you have a bit more to read which I hope will clarify things. <br></p> <h1 id="annealing-the-importance-distribution"><strong>Annealing the Importance Distribution</strong></h1> <d-byline></d-byline> <p>As in IS, we begin by choosing: \(\begin{equation} q(x)=\frac{1}{Z_0}\tilde{q}(x) \end{equation}\) which is easy to sample from and whose normalization constant, $Z_0$, is known.</p> <p>How are we going to get this sample closer to $p(x)$? We’re going to define a series of intermediate distributions that gradually get closer and closer to $p(x)$. For now I’ll define the $T$ intermediate distributions as:</p> \[\begin{aligned} \pi_t(x)&amp;=\tilde{q}(x)^{1-\beta(t)}\cdot\tilde{p}(x)^{\beta(t)}\\ \beta(t)&amp;=t/T \end{aligned}\] <p>where $p(x)=\tilde{p}(x)/Z_T$ is the distribution we’re actually interested in. Notice that $\beta(0)=0$ and $\beta(T)=1$, so:</p> \[\begin{align} \pi_0(x)&amp;=\tilde{q}(x)\\ \pi_T(x)&amp;=\tilde{p}(x) \end{align}\] <p>Furthermore, the values of $\beta(t)$ gradually move from 0 to 1, so for each $t$ the function $\pi_t(x)$ is an unnormalized distribution somewhere between the two distributions $\tilde{q}(x)$ and $\tilde{p}(x)$. These intermediate distributions will allow a smooth transition from the simple distribution to the complex.</p> <p>If we use many iteration $T$, then the difference between each $\pi_t(x)$ and $\pi_{t+1}(x)$ will be very small, such that a sample from $\pi_t(x)$ is almost (but not quite) a valid sample from $\pi_{t+1}(x)$. Accordingly, we can use a relatively lightweight MCMC approach to get a sample from $\pi_{t+1}(x)$ starting from the $\pi_t(x)$ sample. And we can do this for all $t$, starting from the initial simple distribution $\pi_0(x)$.</p> <p>At the same time, the importance weights for $\pi_{t+1}(x)$ given the $\pi_t(x)$ “proposal distribution” are $w_t=\frac{\pi_{t+1}(x)}{\pi_{t}(x)}$. We essentially want to get the importance weights for the whole chain $\pi_0(x)\rightarrow \pi_1(x)\rightarrow\cdots\rightarrow \pi_T(x)$, so we will multiply the time-based importance weights along the way. Ultimately, given a chain of $x_0,\cdots,x_{T-1}$ the importance weight of the whole chain will be given by:</p> \[\begin{equation} w(x_0,\cdots,x_T)=Z_0\frac{\pi_1(x_0)}{\pi_0(x_0)}\cdot\frac{\pi_2(x_1)}{\pi_1(x_1)}\cdots \frac{\pi_T(x_{T-1})}{\pi_{T-1}(x_{T-1})} \end{equation}\] <p>Notice that for all the intermediate $t$s that are not equal to 0 or $T$, the unnormalized distribution $\pi_t(x)$ always appears in the numerator <em>and</em> denominator once, meaning that we don’t need to estimate the normalizing coefficients $Z_t$ as they cancel out.</p> <p>Putting all of this together, the AIS algorithm proceeds as follows (see appendix <a href="#a2-ais-importance-weights**">A.2</a> for something a bit more formal):</p> <blockquote> <ol> <li>sample $x_0\sim q(x)$</li> <li>set $w_0=Z_0$</li> <li>for $t=1,\cdots,T$:</li> <li>$\qquad$set $w_t=w_{t-1}\cdot\frac{\pi_t(x_{t-1})}{\pi_{t-1}(x_{t-1})}$</li> <li>$\qquad$sample $x_t\sim \pi_t(x)$ starting from $x_{t-1}$</li> </ol> </blockquote> <p>That’s it.</p> <h3 id="small-notes">Small Notes</h3> <p>For this post, I chose a particular (“standard”) way to define the intermediate distributions $\pi_t(x)$. However, any set of intermediate distributions can be chosen, as long as the unnormalized form of each of them can be calculated and the change is gradual enough.</p> <p>Additionally to that, while $\pi_t(x)=\pi_0^{1-\beta(t)}(x)\pi_T^{\beta(t)}(x)$ is the definition most often used in practice, $\beta(t)$ is usually <em>not</em> just linear in $t$. There are many options for the scheduling/annealing of $\beta(t)$, where different heuristics are taken into account in the definition of the schedule.</p> <h3 id="examples-and-visualizations">Examples and Visualizations</h3> <details><summary>Implementation details</summary> <p>In all of the following examples, I’m using Langevin dynamics or the Metropolis corrected version (<a href="https://en.wikipedia.org/wiki/Metropolis-adjusted_Langevin_algorithm" rel="external nofollow noopener noopener noreferrer" target="_blank">called MALA</a>) with a single step as the MCMC algorithm between intermediate distributions. Moreover, I always used $q(x)=\mathcal{N}(x;\ 0, I)$ as the proposal distribution.</p> <p>To be honest, this would not work in any real application - a single Langevin step <em>doesn’t</em> sample from the distribution (you usually need many more steps). Luckily, for these visualizations a single step <em>was</em> enough and conveys the message equally well, so I’d rather keep the simpler approach for now.</p> </details> <p>The first example is really simple - the target and proposal distributions are both Gaussian:</p> <div class="l-page"> <p align="center"> <img src="https://github.com/friedmanroy/friedmanroy.github.io/blob/master/assets/blog_figs/AIS/two_gaussians.gif?raw=true" alt="AIS from one Gaussian to another, non-isotropic Gaussian." style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 1: a really simple example of using AIS to anneal between a standard normal to another (non-isotropic) Gaussian. Brighter values indicate regions with higher probability, and the two black dots are the samples across the intermediate distributions. Notice how the intermediate distributions "pull" the two samples after them, finally reaching the target distribution. </div> <p>An important advantage of AIS is that it anneals between a simple distribution, slowly morphing into the more complicated distribution. If properly calibrated, this allows it to sample from all modes:</p> <div class="l-page"> <p align="center"> <img src="https://github.com/friedmanroy/friedmanroy.github.io/blob/master/assets/blog_figs/AIS/1to3_gaussians.gif?raw=true" alt="AIS from one Gaussian to another, non-isotropic Gaussian." style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 2: AIS from one Gaussian to a mixture of 3 Gaussians. When the proposal distribution is properly set, the annealing process ensures that all modes are properly "covered". </div> <p>Of course, AIS can be used to sample from much more complex distributions:</p> <div class="l-page"> <p align="center"> <img src="https://github.com/friedmanroy/friedmanroy.github.io/blob/master/assets/blog_figs/AIS/spiral.gif?raw=true" alt="AIS from one Gaussian to another, non-isotropic Gaussian." style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 3: Notice how AIS doesn't "waste" samples in regions with practically 0 density towards the end. </div> <p><br></p> <h1 id="importance-weights"><strong>Importance Weights</strong></h1> <d-byline></d-byline> <p>The mathematical trick of AIS is the way we defined the weights, $w_T$ (see <a href="#a2-ais-importance-weights">A.2</a> for more details regarding the definition). Like in regular importance sampling, the weights are defined in such a way that:</p> \[\begin{equation} \mathbb{E}_{x_0\sim q}\left[w_T\right]=Z_T \end{equation}\] <p>So, we can use $M$ samples $x_T^{(1)},\cdot,x_T^{(M)}$ and importance weights $w_T^{(1)},\cdots,w_T^{(M)}$ created using the AIS algorithm to estimate the expectation from equation \eqref{eq:f-exp}:</p> \[\begin{equation} \overline{f}\approx\hat{f}= \frac{\sum_i^M w_T^{(i)}f(x_T^{(i)})}{\sum_i^M w_T^{(i)}} \end{equation}\] <p>In fact, this $\hat{f}$ is an unbiased estimator for $\overline{f}$!</p> <h3 id="calculations-in-log-space">Calculations in Log-Space</h3> <p>If you’ve ever dealt with probabilistic machine learning, you probably already know that multiplying many (possible very small) probabilities is a recipe for disaster. This is also true here.</p> <p>Recall:</p> \[\begin{equation} w_T=Z_0\cdot\frac{\pi_1(x_0)}{\pi_0(x_0)}\cdot\frac{\pi_2(x_1)}{\pi_1(x_1)}\cdots\frac{\pi_T(x_{T-1})}{\pi_{T-1}(x_{T-1})} \end{equation}\] <p>In almost all practical use cases, the values $\pi_i(x)$ are going to be very small numbers. So, $w_T$ is the product of many small numbers. If $T$ is very large, it is almost guaranteed that the precision of our computers won’t be able to handle the small numbers and eventually we’ll end up with $w_T=0/0$.</p> <p>Instead, the importance weights are usually calculated in <em>log-space</em>, which modifies the update for the importance weight into:</p> \[\begin{equation} \log w_t=\log w_{t-1}+\log \pi_t(x_{t-1})-\log\pi_{t-1}(x_{t-1}) \end{equation}\] <p>The log-weights can then be averaged to get an estimate of $\log Z_t$… well, almost.</p> <p>Averaging out the log-weights gives us $\mathbb{E}_{x_0\sim q(x)}[\log w_T]$ , however by Jensen’s inequality <d-cite key="grosse2015"></d-cite>:</p> \[\begin{equation} \mathbb{E}_{x_0\sim q}[\log w_T] \le \log \mathbb{E}_{x_0\sim q}[w_T]=\log Z_T \end{equation}\] <p>So, when we use the log of importance weights, it’s important to remember that they only provide us with a <em>stochastic lower bound</em><d-footnote>The lower bound is stochastic because we only get an estimate of $Z_T$ when the number of samples is finite. This makes things a bit hard sometimes: the variance of the estimator can sometimes push the estimate to be larger than the true value, even though it's a lower bound!</d-footnote> of the normalization constant. When $T$ is very large, it can be shown that the variance of the estimator tends to 0, meaning the lower bound becomes tight.</p> <p>Bottom line is: the number of intermediate distributions $T$ should be quite large and carefully calibrated.</p> <h3 id="reversing-the-annealing">Reversing the Annealing</h3> <p>There is a silver lining to the above. If we reverse the AIS procedure, that is start at $\pi_T(x)$ and anneal to $\pi_0(x)$, then we can generate a <em>stochastic upper bound</em> of $Z_T$.</p> <p>Keeping the same notation as above, let $w_T$ be the importance weights of the regular AIS and $m_0$ be the importance weights of the reverse annealing. Then:</p> \[\begin{align} \mathbb{E}_{x_T\sim p}[\log m_0]&amp;\le \log \mathbb{E}_{x_T\sim p}[m_0]=\log\frac{1}{Z_T}\\ \Leftrightarrow \log Z_T&amp;\ge - \mathbb{E}_{x_T\sim p}[\log m_0] \end{align}\] <p>The only problem, which you may have noticed, is that the reverse procedure needs to start from samples out of $p(x)$, our target distribution. Fortunately, such samples were produced by the forward procedure of AIS<d-footnote>This method for finding both the stochastic lower and upper bounds is called <i>bidirectional Monte Carlo</i> <d-cite key="grosse2015"></d-cite>.</d-footnote>!</p> <p><br></p> <h1 id="finding-your-keys"><strong>Finding Your Keys</strong></h1> <d-byline></d-byline> <p>Back to our somewhat contrived problem.</p> <p>Here’s your apartment and the PDF for $p_\text{key}(x)$ representing the distribution of probable key placements:</p> <div class="l-page"> <p align="center"> <img src="https://github.com/friedmanroy/friedmanroy.github.io/blob/master/assets/blog_figs/AIS/room_distribution.png?raw=true" alt="AIS from one Gaussian to another, non-isotropic Gaussian." style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 4: The floor plan with the density of finding the keys at each point in space (brighter is higher density). It's impossible to find the keys outside the house or in the walls, so the darkest blue in this image should be treated as essentially 0 density. </div> <p>Your place is really big<d-footnote>Yeah, the floor design isn't that good... but I'm not an architect or anything, so it's fine.</d-footnote>!</p> <p>As you can see, there are rooms more likely and less likely to contain the keys and there are regions where it would be almost impossible to find the keys (all the places with the darkest shade of blue). Such places are, for instance, outside the house, in the walls or in the middle of a hallway.</p> <p>Conveniently, the rooms are numbered. We want to estimate, given this (unnormalized) PDF the probability that the keys are in a room, say room 7:</p> \[\begin{equation} P(\text{keys}\in R_7)=? \end{equation}\] <p>Well, let’s use AIS to calculate the importance weights. Here’s the compulsory animation:</p> <div class="l-page"> <p align="center"> <img src="https://github.com/friedmanroy/friedmanroy.github.io/blob/master/assets/blog_figs/AIS/keys.gif?raw=true" alt="AIS from one Gaussian to another, non-isotropic Gaussian." style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 5: Running AIS on the floor plan. The points towards the end really look as if they were sampled from the correct distribution, even though it's such a weird one. Also, note that I ran this algorithm for many more iterations than the previous ones - this helped the sampling procedure, but could probably be done with less iterations. </div> <details><summary>More implementation details</summary> <p>Unlike the previous animations, for these trajectories I actually used 100 samples and am only showing 30 (otherwise everything would be full of moving black dots). Also, notice that towards the end of the AIS procedure the particles get “stuck”; this is because I used Metropolis-Hastings acceptance steps<d-footnote>If you are unfamiliar with this term, don't sweat it. Basically, I used a method that rejects sampled points that aren't from the distribution I'm trying to sample from.</d-footnote> and most of the sampling steps towards the end were rejected, because of the really small densities at the edges of the rooms.</p> <p>Also, the annealing for this animation was a bit tricky to set. Because the density outside the house is basically constant (and equal to 0), if the annealing isn’t carefully adjusted points have a tendency of getting stuck there. My solution was to also anneal the impossibility of being in those regions, just in a much slower pace than the other parts of the distribution<d-footnote>If you've ever heard of <i>log-barriers</i> in optimization, then I think it's basically the same concept.</d-footnote>.</p> </details> <p>Using the importance weights accumulated during this sampling procedure, we can now calculate the probability of the keys being in any one of the rooms, for instance room 7:</p> \[\begin{align} P(\text{keys}\in R_7)&amp;=\mathbb{E}_x\left[\textbf{1}[x\in R_7]\right]\\ &amp;\approx\frac{\sum_i w_T^{(i)}\cdot \textbf{1}[x\in R_7]}{\sum_i w^{(i)}_T} \end{align}\] <p>Using this formula to calculate the probabilities of the keys being in each of the rooms, we get:</p> <div class="l-page"> <p align="center"> <img src="https://github.com/friedmanroy/friedmanroy.github.io/blob/master/assets/blog_figs/AIS/key_probabilities.png?raw=true" alt="AIS from one Gaussian to another, non-isotropic Gaussian." style="display: inline-block; margin: 0 auto; "> </p> </div> <div class="caption"> Figure 6: The same floor plan, only with the probabilities of the keys being in any of the rooms overlayed on top. Brighter rooms have higher probability. </div> <p>And there you have it! You should probably check in either room 9 or 6 and only then search in the other rooms.</p> <p><br></p> <h1 id="practical-applications-of-ais"><strong>Practical Applications of AIS</strong></h1> <d-byline></d-byline> <p>While I believe the example in this post is good for visualization and intuition, it’s pretty silly (as I already mentioned). In 2D, rejection sampling probably achieves the same results with much less fuss.</p> <p>The more common use for AIS that I’ve seen around is as a method for <em>Bayesian inference</em> (e.g. <d-cite key="wu2016"></d-cite>).</p> <p>Suppose we have some prior distribution $p(\theta;\ \varphi)$ parametrized by $\varphi$ and a likelihood $p(x\vert\theta)$. Bayesian inference is, at it’s core, all about calculating the posterior distribution and the evidence function:</p> \[\overbrace{p(\theta\vert x;\varphi)}^\text{posterior}=\frac{p(\theta)\cdot p(x\vert \theta)}{\underbrace{p(x;\varphi)}_\text{evidence}}\] <p>For most distributions in the real world this is really really hard. As a consequence, using MCMC methods for sampling from the posterior (or <em>posterior sampling</em>) is very common. However, such methods don’t allow for calculation of the evidence, which is one of the primary ways models are selected in Bayesian statistics.</p> <p>AIS offers an elegant solution both to posterior sampling and evidence estimation. Let’s define our proposal and target distributions once more, adjusted for Bayesian inference:</p> \[\begin{equation} \pi_0(\theta)=p(\theta;\ \varphi)\qquad\ \ \ \ \ \ \ \ \pi_T(\theta)=p(\theta;\varphi)\cdot p(x\vert\ \theta) \end{equation}\] <p>As you have probably already noticed, $\pi_T(\theta)$ is the unnormalized version of the posterior. The normalization constant of $\pi_T(\theta)$ is exactly the evidence. We only need to choose an annealing schedule between the proposal and target distributions. Taking inspiration from our earlier annealing schedule, we can use (for example):</p> \[\begin{equation} \pi_t(\theta)=p(\theta;\varphi)\cdot p(x\vert\theta)^{\beta(t)} \end{equation}\] <p>where $\beta(0)=0$ and $\beta(T)=1$.</p> <p>That’s it. If $T$ is large enough, then we can be sure that the samples procured from the AIS algorithm will be i.i.d. from the posterior. Moreover, the weights $w_T^{(i)}$ can be used to estimate the evidence:</p> \[\begin{equation} p(x;\varphi)\approx \frac{1}{M}\sum_i w_T^{(i)} \end{equation}\] <p>And there you have it! Instead of simply sampling from the posterior, you can get an estimate for the evidence at the same time<d-footnote>As long as you don't use a batched method on many data points $x$ like they do in Bayesian neural networks, I don't think this will work there (although variants do exist).</d-footnote> <br></p> <h1 id="conclusion"><strong>Conclusion</strong></h1> <d-byline></d-byline> <p>You now (maybe) know what annealed importance sampling is and how to use it. My main hope was to give some intuition into what happens in the background when you use AIS. I find the concept of sampling by starting at a simple distribution and moving to a more complex one really cool, especially when it is treated in such a clear and direct manner.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2023-11-25-AIS.bib"></d-bibliography> </div> <d-appendix> <h1 id="appendix">Appendix</h1> <d-byline></d-byline> <h2 id="a1-importance-sampling"><strong>A.1 Importance Sampling</strong></h2> <p>We know how to calculate $\tilde{p}(x)$, but don’t know how to sample from it. The simplest solution for calculating $\overline{f}$ and $Z$ is through what is called <em>importance sampling</em>.</p> <p>Start by choosing a simpler distribution $q(x)$ whose normalization is completely known <em>and</em> is easy to sample from<d-footnote>Also, you have to make sure that the support of $p(x)$ is contained in the support for $q(x)$!</d-footnote>. Then:</p> <p>\(\begin{align} \mathbb{E}_{x\sim p}[f(x)]&amp;=\intop p(x)f(x)dx\\ &amp;=\intop \frac{p(x)}{q(x)}f(x)q(x)dx\\ &amp;=\mathbb{E}_{x\sim q}\left[\frac{p(x)}{q(x)}\cdot f(x)\right] \end{align}\) <br></p> <p>Using $q(x)$, we somehow magically moved the difficulty of sampling $x$ from $p(x)$ to the much simpler operation of sampling $x$ from $q(x)$! The expectation can now be approximated using a finite number of samples. Let $w(x)=p(x)/q(x)$ and generate $M$ samples from the distribution $q(x)$ such that:</p> <p>\(\begin{equation} \mathbb{E}_{x\sim p}\left[f(x)\right]\approx \frac{1}{M}\sum_{i:\ x_i\sim q}^M w(x_i)\cdot f(x_i) \end{equation}\) <br></p> <p>But there’s a problem: we don’t really know how to calculate $p(x)$ (since we don’t know $Z$), only $\tilde{p}(x)$. Fortunately, we can also estimate $Z$ for the same price! Denote $\tilde{w}(x)=\tilde{p}(x)/q(x)$, then:</p> <p>\(\begin{align} Z&amp;=\intop \tilde{p}(x)dx=\intop\frac{\tilde{p}(x)}{q(x)}q(x)dx\\ &amp;=\intop \tilde{w}(x)q(x)dx\\ &amp;=\mathbb{E}_{x\sim q}\left[\tilde{w}(x)\right]\\ &amp;\approx \frac{1}{M}\sum_{i:\ x_i\sim q}^M\tilde{w}(x_i) \end{align}\) <br></p> <p>So, our estimate of $\overline{f}$ is given by:</p> <p>\(\begin{equation} \mathbb{E}_{x\sim p}\left[f(x)\right]\approx \frac{1}{\sum_i\tilde{w}(x_i)}\cdot\sum_{i:\ x_i\sim q}^M \tilde{w}(x_i)\cdot f(x_i) \end{equation}\) <br></p> <p>The $w(x)$ (and their unnormalized versions) are called <em>importance weights</em> as for each $x_i$ they capture the relative importance between $p(x_i)$ and $q(x_i)$.</p> <p>At the limit $M\rightarrow\infty$, the above approximation becomes accurate. Unfortunately, when $M$ is finite, this estimation is biased and in many cases can be very misspecified.</p> <p><br> <br></p> <h2 id="a2-ais-importance-weights"><strong>A.2 AIS Importance Weights</strong></h2> <div class="l-gutter" style="margin-bottom:-1000px;margin-top:30px;color:#aaaaaa"> <b> Prerequisites: </b> <ul style="margin-left:-20px"> <li style="margin:0px"> Markov chains</li> <li style="margin:0px"> Detailed balance</li> <li style="margin:0px"> Importance sampling</li> </ul> </div> <p>To properly understand the construction of the importance weights in AIS, we are going to need to be more precise than my explanation in the main body of text.</p> <p>So, as usual, we have a target distribution $p(x)=\pi_T(x)/Z_T$ and a proposal distribution $q(x)=\pi_0(x)/Z_0$. In between these two distributions, we have $T-1$ intermediate distributions unnormalized distributions, $\pi_1(x),\cdots,\pi_{T-1}(x)$. The missing piece in the original body of text is the fact that we have $T$ different <em>transition operators</em> that are invariant to the different distributions, which we will call $\mathcal{T}_t(x\rightarrow x’)$ for an operation that starts at $x$ and ends at $x’$. In practice, we can think of these as the transition probabilities in a Markov chain.</p> <p>What do I mean by “invariant transition operators”? Well, these will be our sampling algorithms, so Langevin dynamics on the $t$-th distribution, $\pi_t(x)$. The “invariant” part just means that this transition operator maintains <em>detailed balance</em> with respect to the distribution $\pi_t(x)$:</p> <p>\(\begin{equation} \mathcal{T}_t(x\rightarrow x')\frac{\pi_t(x)}{Z_t}=\mathcal{T}_t(x'\rightarrow x)\frac{\pi_t(x')}{Z_t} \end{equation}\) <br></p> <p>As long as $\mathcal{T}_t(x\rightarrow x')$ has this property for every possible pair of $x$ and $x'$, it can be used in AIS.</p> <p>Now, recall that the sampling procedure in AIS was carried out as follows:</p> <center> sample $x_0\sim \pi_0$ </center> <center> generate $x_1$ using $\mathcal{T}_1(x_0\rightarrow x_1)$ </center> <center> $\vdots$ </center> <center> generate $x_T$ using $\mathcal{T}_T(x_{T-1}\rightarrow x_T)$ </center> <p><br> This procedure describes a (non-homogeneous) Markov chain, with transition probabilities determined according to $\mathcal{T}_t$.</p> <p>In the scope of this Markov chain, we can talk about the forward joint probability (starting at $x_0$ and moving to $x_T$) and the reverse joint probability (starting at $x_T$ and going back). At it’s root, AIS is just importance sampling with the reverse joint as the target and the forward as the proposal. Mathematically, define:</p> <p>\(\begin{align} \pi(x_0,\cdots,x_T)&amp;=\pi_T(x_T)\cdot\mathcal{T}_T(x_T\rightarrow x_{T-1})\cdots \mathcal{T}_1(x_1\rightarrow x_0)\\ q(x_0,\cdots,x_T)&amp;=q(x_0)\cdot\mathcal{T}_1(x_0\rightarrow x_1)\cdots \mathcal{T}_T(x_{T-1}\rightarrow x_T) \end{align}\) <br></p> <p>Of course, we never actually observe $T_t(x_t\rightarrow x_{t-1})$, only the opposite direction. How can we fix this? Well, using detailed balance:</p> <p>\(\begin{equation} \mathcal{T}_t(x_t\rightarrow x_{t-1})=\frac{\pi_t(x_{t-1})}{\pi_t(x_t)}\cdot\mathcal{T}_t(x_{t-1}\rightarrow x_t) \end{equation}\) <br></p> <p>This neat property allows us to write the full form of the importance weights<d-footnote>Getting to the last line requires rearranging the terms and using the equation above for the reverse transition, but this post is already pretty long and I don't think adding that math particularly helps here... Everything cancels out nicely and we get the form for the importance weights as in the main text!</d-footnote>:</p> <p>\(\begin{align} w=&amp;\frac{\pi(x_0,\cdots,x_T)}{q(x_0,\cdots,x_T)}\\ &amp;=\frac{\pi_T(x_T)}{q(x_0)}\cdot\frac{\mathcal{T}_T(x_T\rightarrow x_{T-1})\cdots \mathcal{T}_1(x_1\rightarrow x_0)}{\mathcal{T}_1(x_0\rightarrow x_1)\cdots \mathcal{T}_T(x_{T-1}\rightarrow x_T)}\\ &amp;=Z_0\cdot \frac{\pi_1(x_0)}{\pi_0(x_0)}\cdot\frac{\pi_2(x_1)}{\pi_1(x_1)}\cdots\frac{\pi_T(x_{T-1})}{\pi_{T-1}(x_{T-1})} \end{align}\) <br></p> <p>These importance weights are exactly the same as those defined in the main body of text, but their motivation is maybe clear now?</p> <p>The important point is that the proposal distribution creates a path from $x_0$ to $x_T$ while the “true target distribution” is the path from $x_T$ to $x_0$. So the importance weighting is now the forward path $\stackrel{\rightarrow}{\mathcal{T}}(x_0\rightarrow x_T)$ as a simpler alternative to the reverse path $\stackrel{\leftarrow}{\mathcal{T}}(x_T\rightarrow x_0)$.</p> <p>To hammer this point home, the normalization constant for $\pi_T(x)$ can be found by taking the expectation with regards to the forward paths: \(\begin{equation} Z_T=\mathbb{E}_{\stackrel{\rightarrow}{\mathcal{T}}(x_0\rightarrow x_T)}\left[w\right]=\mathbb{E}_{\stackrel{\rightarrow}{\mathcal{T}}(x_0\rightarrow x_T)}\left[\frac{\pi_T(x_T)\stackrel{\leftarrow}{\mathcal{T}}(x_T\rightarrow x_0)}{q(x_0)\stackrel{\rightarrow}{\mathcal{T}}(x_0\rightarrow x_T)}\right] \end{equation}\)</p> <d-byline></d-byline> <p>That was… probably hard to follow. Hopefully I got some of the message across - there is a Markov chain that goes from $q(x)$ to $\pi_T(x)$ and the reverse of it. If you understood that, and are comfortable with importance sampling, then you’re fine. It’ll sink in if you think about it a bit more.</p> <p>This is a neat mathematical trick, though. Theoretically, it is no different than standard importance sampling, we just defined weird proposal and target distributions. Transforming the a simple distribution to something close to the target, though, that’s the core of it.</p> <p>If you read this far, well, I commend you. Good luck using AIS!</p> </d-appendix> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>