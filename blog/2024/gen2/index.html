<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Generative Models 2 - Variational Methods | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content=""> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/blog/2024/gen2/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Generative Models 2 - Variational Methods",
      "description": "",
      "published": "August 20, 2024",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Generative Models 2 - Variational Methods</h1> <p></p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#evidence-lower-bound-elbo">Evidence Lower Bound (ELBO)</a></div> <div><a href="#classical-variational-inference-vi">Classical Variational Inference (VI)</a></div> <div><a href="#variational-auto-encoders-vaes">Variational Auto-Encoders (VAEs)</a></div> <div><a href="#conclusion">Conclusion</a></div> </nav> </d-contents> <p><span style="float:left"><a href="https://friedmanroy.github.io/blog/2024/gen1/">← A Linear Model</a></span><span style="float:right"><a href="https://friedmanroy.github.io/blog/2024/gen3/">Normalizing Flows →</a></span> <br></p> <d-byline></d-byline> <p>In the previous post we saw how to define $x=G_{\theta}\left(z\right)$ such that $p\left(x;\theta\right)$ is tractable (can be calculated easily). But what if we wanted to use more general decoders? For instance, we believe that the latent space is in a lower dimension, but that the decoder is not linear. What do we do in that case?</p> <p>If we want to calculate $\log p_{\theta}\left(x\right)$ in general models, we’re going to have to start approximating some things. After all, calculating:</p> \[\begin{equation} \log p_{\theta}\left(x\right)=\log\intop p_{\theta}\left(x\vert z\right)p\left(z\right)dz \end{equation}\] <p>is going to be impossible in almost every scenario.</p> <p><em>Variational methods</em>, the focus of this section, attempt to lower-bound the log-likelihood instead of calculating it exactly. Recall, our goal is to maximize the expected log-likelihood:</p> \[\begin{equation} \text{goal:}\;\text{find }\arg\max_{\theta}\mathbb{E}_{p_{\text{data}}}\left[\log p\left(x;\theta\right)\right] \end{equation}\] <p>If we can find a lower bound $\log p\left(x;\theta\right)\ge\phi\left(x;\theta\right)$ and maximize $\phi\left(x;\theta\right)$, then we know that our distribution will be at least as good as that.</p> <p><br></p> <h1 id="evidence-lower-bound-elbo"><strong>Evidence Lower Bound (ELBO)</strong></h1> <d-byline></d-byline> <p>Finding a lower bound for the log-likelihood sounds kind of difficult, but follows a set of simple steps. To find the lower bound, we will need a guess for $p_{\theta}\left(z\vert x\right)$. Let’s call this guess $q_{\phi}\left(z\vert x\right)$. The log-likelihood can now be written as:</p> \[\begin{align} \log p_{\theta}\left(x\right) &amp; =\log\intop p_{\theta}\left(x,z\right)dz\\ &amp; =\log\intop p_{\theta}\left(x,z\right)\frac{q_{\phi}\left(z\vert x\right)}{q_{\phi}\left(z\vert x\right)}dz\\ &amp; =\log\mathbb{E}_{q_{\phi}}\left[\frac{p_{\theta}\left(x,z\right)}{q_{\phi}\left(z\vert x\right)}\right]\\ &amp; \ge\mathbb{E}_{q_{\phi}}\left[\log p_{\theta}\left(x\vert z\right)+\log\frac{p\left(z\right)}{q_{\phi}\left(z\vert x\right)}\right]\\ &amp; =\mathbb{E}_{q_{\phi}}\left[\log p_{\theta}\left(x\vert z\right)\right]-D_{\text{KL}}\left(q_{\phi}\left(z\vert x\right)\vert \vert p\left(z\right)\right)\\ &amp; =-F\left(x;\theta,\phi\right)\label{eq:free-energy} \end{align}\] <p>The last step is due to Jensen’s inequality. Notice how this is true for any $q_{\phi}\left(z\vert x\right)$ - we now have a lower bound on the log-likelihood! The value $F\left(x;\theta,\phi\right)$ is sometimes called the <em>free energy</em> for reasons that are broadly trivia and specifically way too complicated to actually talk about. At any rate, it’s useful to know that it’s called the free energy, so you won’t be surprised if you see the name ever again.</p> <p>When is this lower bound tight? If we happen to choose $q_{\phi}\left(z\vert x\right)=p_{\theta}\left(z\vert x\right)$, then:</p> \[\begin{align} \log p_{\theta}\left(x\right) &amp; \ge\mathbb{E}_{q_{\phi}\left(z\vert x\right)}\left[\log\frac{p_{\theta}\left(z\vert x\right)}{q_{\phi}\left(z\vert x\right)}+\log p_{\theta}\left(x\right)\right]\\ &amp; =\mathbb{E}_{p_{\theta}\left(z\vert x\right)}\left[\log\frac{p_{\theta}\left(z\vert x\right)}{p_{\theta}\left(z\vert x\right)}+\log p_{\theta}\left(x\right)\right]\\ &amp; =\mathbb{E}_{p_{\theta}\left(z\vert x\right)}\left[\log p_{\theta}\left(x\right)\right]=\log p_{\theta}\left(x\right) \end{align}\] <p>So, <em>the best</em> guess we can have for $q_{\phi}\left(z\vert x\right)$ is the conditional distribution we are approximating to begin with, $p_{\theta}\left(z\vert x\right)$.</p> <p>In practice, we will assume a simple form for $q_{\phi}\left(z\vert x\right)$, almost always a Gaussian distribution. The quality of the lower bound will then be the difference from the guess $q_{\phi}\left(z\vert x\right)$ and the true posterior $p_{\theta}\left(z\vert x\right)$.</p> <p><br></p> <h1 id="classical-variational-inference-vi"><strong>Classical Variational Inference (VI)</strong></h1> <d-byline></d-byline> <p>What we wrote above in equation \eqref{eq:free-energy} is a lower for the log-likelihood of a <em>single data point</em>. Remember, what we actually want to maximize is the log-likelihood of <em>all training examples</em>. The “traditional” way <d-cite key="blei2017variational"></d-cite> to use this lower bound for training a model is to alternate the following steps:</p> \[\begin{align} \left(I\right)\qquad &amp; \text{for }i=1,\cdots,N:\quad\hat{\phi}_{i}=\arg\max_{\phi}-F\left(x_{i};\theta^{\left(t-1\right)},\phi\right)\\ \left(II\right)\qquad &amp; \theta^{\left(t\right)}=\arg\max_{\theta}\left\{ -\frac{1}{N}\sum_{i=1}F\left(x_{i};\theta,\hat{\phi}_{i}\right)\right\} \end{align}\] <p>The first step gives us a better lower bound for the true log-likelihood. The second step is where we make a better prediction of the parameters $\theta$ under the specific lower bound.</p> <p>Notice that step $\left(I\right)$ basically requires an <em>optimization of a distribution for every observed data point</em> $x_{i}$. This is quite expensive. However, as a byproduct we get, for the same price, the approximation $q\left(z\vert x_{i};\hat{\phi}_{i}\right)$ for each posterior $p\left(z\vert x_{i};\hat{\theta}\right)$. This can sometimes be useful (maybe more on that later on).</p> <details><summary>Example</summary> <p>I’ve kept everything pretty vague until now, so an example might be good right about now.</p> <p>Let’s, for a moment, imagine that we don’t know how to find the posterior distribution for the pPCA. Our model is:</p> \[\begin{equation} p_{\theta}\left(x,z\right)=\mathcal{N}\left(z\vert \;0,I\right)\times\mathcal{N}\left(x\vert \;\mu+Wz,\;I\varphi^{2}\right) \end{equation}\] <p>Our parameters are $\theta=\left\{ \mu,W,\varphi\right\}$. We are assuming that we don’t know the posterior distribution, so let’s approximate it with some other distribution. The simplest distribution to use many times is a isotropic Gaussian, so let’s define:</p> \[\begin{equation} \phi=\left\{ m,\sigma^{2}\right\} \qquad q_{\phi}\left(z\vert x\right)=\mathcal{N}\left(z\vert \:m,I\sigma^{2}\right)\approx p_{\theta}\left(z\vert x\right) \end{equation}\] <p>Now, for each data point $x_{i}$, we will try to optimize $\phi_{i}$ so the following is as high as possible:</p> \[\begin{align} \hat{\phi}\left(x_{i}\right) &amp; =\arg\max_{\phi}-F\left(x_{i};\theta,\phi\right)\\ &amp; =\arg\max_{\phi}\left\{ \mathbb{E}_{q_{\phi}}\left[\log p_{\theta}\left(x_{i}\vert z\right)\right]- D_{\text{KL}}\left(q_{\phi}\left(z\vert x_{i}\right)\vert \vert p\left(z\right)\right)\right\} \end{align}\] <p>This seems quite difficult to calculate. Luckily for us, both $p\left(z\right)$ and $q_{\phi}\left(z\vert x_{i}\right)$ are Gaussian distributions, so the KL-divergence between the two has a closed-form expression:</p> \[\begin{align} D_{\text{KL}}\left(q_{\phi}\left(z\vert x_{i}\right)\vert \vert p\left(z\right)\right) &amp; =\frac{1}{2}\left(\text{trace}\left(I\sigma^{2}\right)-\text{dim}\left(z\right)+\| m\| ^{2}-\log\left\vert I\sigma^{2}\right\vert \right)\\ &amp; =\frac{\text{dim}\left(z\right)}{2}\left(\sigma^{2}-\log\sigma^{2}\right)+\frac{1}{2}\| m\| ^{2} \end{align}\] <p>So that’s one part of the lower bound we can directly calculate. How about the expectation? Well, in this case there is also a closed-form expression for the expectation, but many times there won’t be. Instead, we can try to approximate $\mathbb{E}_{q_{\phi}}\left[\log p_{\theta}\left(x_{i}\vert z\right)\right]$ using, you guessed it, Monte Carlo (MC) samples. Basically, we will draw $M$ samples from $z_{j}\sim q_{\phi}\left(z\vert x_{i}\right)$ and approximate the expectation using these samples:</p> \[\begin{equation} \mathbb{E}_{q_{\phi}}\left[\log p_{\theta}\left(x_{i}\vert z\right)\right]\approx\frac{1}{M}\sum_{j:\,z_{j}\sim q_{\phi}\left(z\vert x_{i}\right)}^{M}\log p_{\theta}\left(x_{i}\vert z_{j}\right) \end{equation}\] <p>Putting all of that together, for each data point $x_{i}$ we will try to find $\hat{\phi}_{i}=\left\{ m_{i},\sigma_{i}^{2}\right\}$ that maximizes the following:</p> \[\begin{align} \hat{\phi}_{i}$=\arg\max_{\phi}\left\{ \frac{1}{M}\sum_{j:\,z_{j}\sim q_{\phi}\left(z\vert x_{i}\right)}^{M}\log p_{\theta}\left(x_{i}\vert z_{j}\right) \right. \\ \left. -\frac{\text{dim}\left(z\right)}{2}\left(\sigma^{2}- \log\sigma^{2}\right)+\frac{1}{2}\| m\| ^{2}\right\} \end{align}\] <p>If we do this for each $x_{i}$, then our <em>lower-bound</em> for the expected log-likelihood of the whole data will be:</p> \[\begin{align} \frac{1}{N}\sum_{i=1}^{N}\log p_{\theta}\left(x_{i}\right) &amp; \ge\frac{1}{N}\sum_{i=1}^{N}\left[\frac{1}{M}\sum_{j:\,z_{j}\sim q_{\hat{\phi}_{i}}\left(z\vert x_{i}\right)}^{M}\log p_{\theta}\left(x_{i}\vert z_{j}\right)\right. \\&amp; \left. -\frac{\text{dim}\left(z\right)}{2}\left(\sigma_{i}^{2}-\log\sigma_{i}^{2}\right)+\frac{1}{2}\| m_{i}\| ^{2}\right] \end{align}\] <p>If that seems to you like a really round about way to get a lower bound for the log-likelihood then, well, I don’t blame you.</p> </details> <p><br></p> <h1 id="variational-auto-encoders-vaes"><strong>Variational Auto-Encoders (VAEs)</strong></h1> <d-byline></d-byline> <p>Variational auto-encoders (VAEs, <d-cite key="kingma2013auto"></d-cite>) attempt to do the above in a way that is slightly more efficient. Instead of optimizing the parameters $\phi$ for each data point $x_{i}$ individually, an encoder is trained to try and predict them. At the same time, the mapping from $\mathcal{Z}$ to $\mathcal{X}$ is also trained.</p> <p>Concretely, suppose $z\sim\mathcal{N}\left(0,I\right)$. Because there’s a closed-form expression for the KL-divergence between two Gaussians, and because it’s easy to sample from a Gaussian, it will be convenient if we assume that:</p> \[\begin{equation} q_{\phi}\left(z\vert x\right)=\mathcal{N}\left(z\vert \:\mu_{\phi}\left(x\right),\Sigma_{\phi}\left(x\right)\right) \end{equation}\] <p>In other words, our guess for the posterior $p_{\theta}\left(z\vert x\right)$ is a Gaussian distribution whose mean and covariance are functions of the observed data, $x$. In practice, a neural network (NN) will be used to <em>encode</em> $x$ into the mean $\mu_{\phi}\left(x\right)$ and covariance $\Sigma_{\phi}\left(x\right)$. Now, instead of finding $\hat{\phi}_{i}$ as we did in VI before, we’ll just try to train the encoder $\mu_{\phi}\left(x_{i}\right)$ and $\Sigma_{\phi}\left(x_{i}\right)$ to give a good guess for the posterior.</p> <p>In other words, we’ll train both the encoders and the decoder, $G_{\theta}\left(z\right)$, at the same time using the usual variational loss we saw in equation \eqref{eq:free-energy}:</p> \[\begin{equation} \left\{ \hat{\theta},\hat{\phi}\right\} =\arg\max_{\theta,\phi}\left\{ \frac{1}{N}\sum_{i=1}^{N}\left[\mathbb{E}_{q_{\phi}}\left[\log p_{\theta}\left(x_{i}\vert G_{\theta}\left(z\right)\right)\right]-D_{\text{KL}}\left(q_{\phi}\left(z\vert x_{i}\right)\vert \vert p\left(z\right)\right)\right]\right\} \end{equation}\] <p>As we mentioned earlier, we know how to calculate $D_{\text{KL}}\left(q_{\phi}\left(z\vert x_{i}\right)\vert \vert p\left(z\right)\right)$ exactly:</p> \[\begin{equation} D_{\text{KL}}\left(q_{\phi}\left(z\vert x_{i}\right)\vert \vert p\left(z\right)\right)=\frac{1}{2}\left(\text{trace}\left[\Sigma_{\phi}\left(x_{i}\right)\right]+\| \mu_{\phi}\left(x_{i}\right)\| ^{2}-\log\left\vert \Sigma_{\phi}\left(x_{i}\right)\right\vert -\text{dim}\left(z\right)\right) \end{equation}\] <p>which will be pretty simple to calculate on the fly.</p> <p>But we are missing other ingredients. For instance, how should we define the observation model $p_{\theta}\left(x\vert G_{\theta}\left(z\right)\right)$? And how do we calculate (and back-propagate through) the expectation of the first term?</p> <p>In a second we’ll get to what people usually use for the observation model, but for now let’s leave it up to the user. Having defined $p_{\theta}\left(x\vert G_{\theta}\left(z\right)\right)$, we’re still left with the question of how to calculate the expectation. What is usually done is the most straightforward - simply use an MC approximation. Actually, approximate the expectation with <em>a single sample</em> from $q_{\phi}\left(z\vert x_{i}\right)$:</p> \[\begin{equation} \mathbb{E}_{q_{\phi}}\left[\log p_{\theta}\left(x_{i}\vert G_{\theta}\left(z\right)\right)\right]\approx\log p_{\theta}\left(x_{i}\vert G_{\theta}\left(\tilde{z}\right)\right)\quad\tilde{z}\sim\mathcal{N}\left(\mu_{\phi}\left(x_{i}\right),\Sigma_{\phi}\left(x_{i}\right)\right) \end{equation}\] <p>While this sounds kind of ridiculous, it actually works okay.</p> <h3 id="observation-model">Observation Model</h3> <p>The most common observation model is, as you probably already guessed, simply a Gaussian distribution:</p> \[\begin{equation} \log p_{\theta}\left(x\vert G_{\theta}\left(z\right)\right)=-\frac{\beta}{2}\| x-G_{\theta}\left(z\right)\| ^{2}+\frac{\text{dim}\left(x\right)}{2}\log\beta+\text{const} \end{equation}\] <p>where $1/\beta$ is the variance of the observation model. In vanilla VAEs, $\beta$ is almost ubiquitously set to 1. If we think about the whole story so far, this is like assuming that every example has been observed with Gaussian noise whose variance is 1. This might make sense some times, but in images (for instance) where pixels take values between 0 and 1, maybe it doesn’t make sense? Just something to think about.</p> <p>Anyway, setting $\beta=1$, we get the “standard” VAE loss (ignoring constants and multiplicative factors, as is usually done):</p> \[\begin{equation} L\left(\theta,\phi\right)=\underbrace{\| x-G_{\theta}\left(z\right)\| ^{2}}_{\text{reconstruction}}+\underbrace{\text{trace}\left[\Sigma_{\phi}\left(x_{i}\right)\right]+\| \mu_{\phi}\left(x_{i}\right)\| ^{2}-\log\left\vert \Sigma_{\phi}\left(x_{i}\right)\right\vert }_{\text{KL term}} \end{equation}\] <p>If we use a different value for $\beta$, we recover something called $\beta$-VAEs:</p> \[\begin{equation} L_{\beta}\left(\theta,\phi\right)=\beta\cdot\| x-G_{\theta}\left(z\right)\| ^{2}+\text{trace}\left[\Sigma_{\phi}\left(x_{i}\right)\right]+\| \mu_{\phi}\left(x_{i}\right)\| ^{2}-\log\left\vert \Sigma_{\phi}\left(x_{i}\right)\right\vert \end{equation}\] <p><br></p> <h1 id="conclusion"><strong>Conclusion</strong></h1> <d-byline></d-byline> <p>VAEs, as described in this post, are very general. We didn’t impose any conditions on the decoder (or the encoder) in any real way, and in theory they should work quite well. In practice, however, (when used in vision) VAEs tend to produce very blurry images. For a long time, the observation model was blamed for these subpar results<d-footnote>I'm happy those concerns have faded away after the success of diffusion models.</d-footnote>, but it’s not really clear why they underperform in the task of generation. As a consequence of this bad performance, many additions were added onto the vanilla VAE. These include using a more expressive variational distribution ($q_{\phi}(z)$, <d-cite key="tomczak2018vae"></d-cite>), adding more MCMC samples with appropriate weights in the ELBO calculation (<d-cite key="burda2015importance"></d-cite>), and changing the observation model (<d-cite key="larsen2016autoencoding"></d-cite>). None of these seem to help in a meaningful way, as far as I know (<d-cite key="chadebec2022pythae"></d-cite>).</p> <p>While VAEs are kind of unpopular at the moment, they are still a very good introduction into generative models. Moreover, they are still used to some extent - the most ubiquitous use is as auto-encoders for other generative models (<d-cite key="rombach2022high"></d-cite>). The fact that they inherently give a lower bound for the likelihood of newly observed samples is also a major plus.</p> <p><br></p> <d-byline></d-byline> <p><span style="float:left"><a href="https://friedmanroy.github.io/blog/2024/gen1/">← A Linear Model</a></span><span style="float:right"><a href="https://friedmanroy.github.io/blog/2024/gen3/">Normalizing Flows →</a></span></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/primer_generative_biblio.bib"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>