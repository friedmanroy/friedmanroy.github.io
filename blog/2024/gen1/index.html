<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="fqpmQwGNtZ1kJ8UAsQMb7RD2N7DcYRDlyGbAJsnZuGM"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Generative Models 1 - A Linear Model | Roy Friedman</title> <meta name="author" content="Roy Friedman"> <meta name="description" content=""> <meta name="keywords" content="academic-website, roy-friedman, machine-learning, ML, bayesian, PhD"> <meta name="google-site-verification" content="EUCyoY6MaSyn4ZvM9TfAuzzeleW7dR0PHS4_UCtyZ4I"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://friedmanroy.github.io/blog/2024/gen1/"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Generative Models 1 - A Linear Model",
      "description": "",
      "published": "August 20, 2024",
      "authors": [
        {
          "author": "Roy Friedman",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Hebrew University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Roy </span>Friedman</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/BML/">Bayesian Machine Learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/_pages/cv/">CV</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Generative Models 1 - A Linear Model</h1> <p></p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#a-linear-model">A Linear Model</a></div> <div><a href="#likelihood">Likelihood</a></div> <div><a href="#maximizing-the-likelihood">Maximizing the Likelihood</a></div> <div><a href="#relation-to-pca">Relation to PCA</a></div> <div><a href="#practical-considerations">Practical Considerations</a></div> <div><a href="#conclusion">Conclusion</a></div> </nav> </d-contents> <p><span style="float:left"><a href="https://friedmanroy.github.io/blog/2024/gen0/">← What is a Generative Model?</a></span><span style="float:right"><a href="https://friedmanroy.github.io/blog/2024/gen2/">Variational Methods →</a></span> <br></p> <d-byline></d-byline> <blockquote> <p>Last post we saw a very general introduction and definition of generative models. In this post we’ll take a look at a specific class of very simple generative models.</p> </blockquote> <d-byline></d-byline> <h1 id="a-linear-model-probabilistic-principal-component-analysis"><strong>A Linear Model (Probabilistic Principal Component Analysis)</strong></h1> <p>For now, I’m staying with the latent space models, or decoder-based generative models, as very very loosely defined in the previous post. We’ll start off with the most basic decoder: a linear transformation. We will also assume that the latent codes are standard normal, so that everything’s nice and easy. Observed data points are now modeled through:</p> \[\begin{equation} x=Wz+\mu\qquad z\sim\mathcal{N}\left(0,I\right) \end{equation}\] <p>I’ll also assume that $z\in\mathbb{R}^{m}$ and $x\in\mathbb{R}^{d}$ such that $m\ll d$. However, if $m&lt;d$ then we might face a problem: the probability of ever sampling something not on this linear transformation is zero! However, real-world examples will probably never neatly lie on a hyperplane.</p> <p>Instead we’re going to have to assume that there was some noise added during the observation of $x$, i.e.:</p> \[\begin{equation} x=Wz+\mu+\text{noise} \end{equation}\] <p>The simplest noise we can assume is an isotropic Gaussian (the noise is the same in all directions), which will give us:</p> \[\begin{equation} p_{\theta}\left(x|z\right)=\mathcal{N}\left(x|\ Wz+\mu,I\varphi^{2}\right) \end{equation}\] <p>where $\varphi$ is the standard deviation of the noise we assume was added. Conveniently, this can be written in the following form:</p> \[\begin{equation} x=\mu+Wz+\varphi\cdot\eta\qquad z\sim\mathcal{N}\left(0,I_{m}\right),\:\eta\sim\mathcal{N}\left(0,I_{d}\right) \end{equation}\] <p>The joint distribution for our model is now very simply:</p> \[\begin{align} p_{\theta}\left(z,x\right) &amp; =p\left(z\right)p_{\theta}\left(x|z\right)\\ &amp; =\mathcal{N}\left(z|\,0,I_{m}\right)\times\mathcal{N}\left(x|\,\mu+Wz,\:I_{d}\varphi^{2}\right) \end{align}\] <p>with the set of parameters $\theta=\left{ \mu\in\mathbb{R}^{d},W\in\mathbb{R}^{d\times m},\varphi\in\mathbb{R}_{+}\right}$ . That’s $d\cdot\left(m+1\right)+1$ parameters.</p> <p>As defined, the above is the generative model equivalent of linear regression. This model is also called a probabilistic principal component analysis (pPCA, <d-cite key="tipping1999probabilistic"></d-cite>) model, for reasons that will become clear in a bit.</p> <p><br></p> <h1 id="likelihood">Likelihood</h1> <d-byline></d-byline> <p>We are now dealing with multiplications and additions of Gaussian distributions. This makes calculating the likelihood extremely simple, as it means that it will also be Gaussian<d-footnote>See my <a href="https://friedmanroy.github.io/BML/3_gaussians/">notes on the Gaussian distribution</a> for more information.</d-footnote>.</p> <p>Our goal is to maximize the log-likelihood. To do so, we first need to be able to calculate the log-likelihood. Luckily, $x$ is a linear transformation of a Gaussian plus another Gaussian. That is, the marginal $p_{\theta}\left(x\right)$ will also be a Gaussian distribution, which is completely described by the mean and covariance. So let’s calculate the mean and covariance of $x$:</p> \[\begin{align} \mathbb{E}\left[x\right] &amp; =W\mathbb{E}\left[z\right]+\mu+\varphi\cdot\mathbb{E}\left[\eta\right]=\mu\\ \text{cov}\left[x\right] &amp; =W\text{cov}\left[z\right]W^{T}+\varphi^{2}\text{cov}\left[\eta\right]=WW^{T}+I\varphi^{2} \end{align}\] <p>So, the likelihood of $x$ under our model is:</p> \[\begin{equation} p\left(x;\theta\right)=\mathcal{N}\left(x|\;\mu,\:WW^{T}+I\varphi^{2}\right) \end{equation}\] <p><br></p> <h1 id="maximizing-the-likelihood">Maximizing the Likelihood</h1> <d-byline></d-byline> <p>The model we described is basically a Gaussian. The ML solution for a Gaussian is simple. Given our dataset $\mathcal{D}=\left{ x_{i}\right} _{i=1}^{N}$, the best mean is:</p> \[\begin{equation} \hat{\mu}=\frac{1}{N}\sum_{i=1}^{N}x_{i} \end{equation}\] <p>The best covariance we can hope for is:</p> \[\begin{equation} S=\frac{1}{N}\sum_{i=1}^{N}\left(x_{i}-\hat{\mu}\right)\left(x_{i}-\hat{\mu}\right)^{T} \end{equation}\] <p>However, the covariance in our model has a specific parameterization. Basically, we want to find $W$ and $\varphi$ such that:</p> \[\begin{equation} \Sigma_{W}\stackrel{\Delta}{=}WW^{T}+I\varphi^{2}\approx S \end{equation}\] <p>The best $W$ and $\varphi$ are explicitly related to $S$, and we’ll need the EVD of the data’s covariance to define them:</p> \[\begin{equation} S=U\Lambda U^{T} \end{equation}\] <p>where $\Lambda_{ij}=0$ whenever $i\neq j$ and the eigenvalues $\lambda_{i}=\Lambda_{ii}$ are sorted in descending order. The MLE solution for $W$ and $\varphi$ turns out to be (see <d-cite key="tipping1999probabilistic"></d-cite> for the derivation):</p> \[\begin{align} \hat{\varphi}^{2} &amp; =\frac{1}{d-m}\sum_{i=m+1}^{d}\lambda_{i}\\ \hat{W} &amp; =U_{1:m}\left(\Lambda_{1:m}-\hat{\varphi}^{2}\right)^{1/2} \end{align}\] <p>where $U_{1:m}\in\mathbb{R}^{d\times m}$ are the first $m$ columns of $U$ (the first $m$ eigenvectors) and $\Lambda_{1:m}\in\mathbb{R}^{m\times m}$ are the first $m$ eigenvalues in $\Lambda$.</p> <p>Essentially, all we need to do in order to fit this linear model is to calculate the mean of the dataset and the SVD of the centered datapoints, since:</p> \[\begin{equation} \text{SVD}\left(\left\{ x_{1}-\hat{\mu},\cdots,x_{N}-\hat{\mu}\right\} \right)=U\Lambda^{1/2}V \end{equation}\] <p>This spares us from calculating the full data covariance $S$, which may sometimes be difficult/impossible to calculate when the dimensions of the data are very very large.</p> <p><br></p> <h1 id="relation-to-pca"><strong>Relation to PCA</strong></h1> <d-byline></d-byline> <p>This linear model, as I mentioned, is called the <em>probabilistic principal component analysis</em> (pPCA) model. This name is because we model distribution as sitting mostly on the hyperplane described by the first $m&lt;d$ principal components of the dataset. Of course, data points don’t actually lie inside this hyperplane, and this discrepancy is modeled as additional isotropic noise. Simply put: this model is a probabilistic version of PCA. When $\varphi\rightarrow0$, it is exactly equal to the standard PCA.</p> <p>The main advantage of this model is it’s simplicity and obvious modeling assumptions. The model is simple because it is basically a Gaussian with a low-rank covariance, and what it means for the data to be modeled as a linear transformation of a standard normal distribution is pretty clear. In this sense, pPCA is a very good baseline for comparing other generative models. Also, sometimes it is surprising just how much can be described by this simple linear function.</p> <h3 id="related-models">Related Models</h3> <p>This is a pretty good place to discuss models similar to pPCA. Remember, we defined a pPCA as:</p> \[\begin{equation} \text{pPCA:}\qquad x=\mu+Wz+\eta\qquad\begin{matrix}\eta\sim\mathcal{N}\left(0,I\varphi^{2}\right)\\ z\sim\mathcal{N}\left(0,I\right) \end{matrix} \end{equation}\] <p>A closely related model is the <em>factor analysis</em> (FA) model, defined as basically the same thing:</p> \[\begin{equation} \text{FA}:\qquad x=\mu+Wz+\tilde{\eta}\qquad\begin{matrix}\tilde{\eta}\sim\mathcal{N}\left(0,\text{diag}\left(\varphi_{1}^{2},\cdots,\varphi_{d}^{2}\right)\right)\\ z\sim\mathcal{N}\left(0,I\right) \end{matrix} \end{equation}\] <p>The difference is that an FA allows different dimensions to have different amounts of noise, basically taking into account their scales. Funnily enough, this rather small change already makes it so there is no closed-form solution for the MLE. Instead, an <em>expectation maximization</em> (EM) algorithm has to be used to fit this model.</p> <p>Another model that should be considered as a baseline is a <em>pPCA mixture model</em> (pPCAMM or MoPPCA, <d-cite key="tipping1999mixtures"></d-cite>), which basically gathers a bunch of pPCAs into one model:</p> \[\begin{equation} p_{\theta}\left(x\right)=\sum_{k=1}^{K}\pi_{k}\text{pPCA}\left(x|\;\mu_{k},W_{k},\varphi_{k}\right)\qquad\begin{matrix}\forall k\quad\pi_{k}\ge0\\ \sum_{k}\pi_{k}=1 \end{matrix} \end{equation}\] <p>This is like the difference between a single Gaussian and a Gaussian mixture model (GMM). FAs can also (as any other distribution) be gathered this way, of course.</p> <p><br></p> <h1 id="practical-considerations"><strong>Practical Considerations</strong></h1> <d-byline></d-byline> <p>We basically covered everything I wanted to cover with regards to pPCAs. I would be remiss, however, not to give a brief overview of how these models can actually be used in practice.</p> <p>As stated, $W\in\mathbb{R}^{d\times m}$ with $m\ll d$. If you’re using a pPCA and not a regular Gaussian, then the dimension of the data is probably large. Very large. However, in order to get the likelihood of data points, you’ll need to calculate, store in memory, and even invert the full covariance:</p> \[\begin{equation} \Sigma_{W}=WW^{T}+I\varphi^{2} \end{equation}\] <p>This matrix is a $d\times d$ matrix, which is a huge pain when $x$ is… huge. Intuitively, it doesn’t make sense that we need to calculate something in $d$ dimensions if we already know that it is a mostly $m&lt;d$ dimensional object. This intuition is correct.</p> <p>Almost all operations with Gaussians require inverting the covariance matrix. It turns out that there’s a mathematical equivalence, known as Woodbury’s matrix identity (among other names), that simplifies the inversion of low-rank matrices such as $\Sigma_{W}$ considerably:</p> \[\begin{align} \underbrace{\left(WW^{T}+I_{d}\varphi^{2}\right)^{-1}}_{d\times d\text{ inversion}} &amp; =\left(I_{d}-W\underbrace{\left(W^{T}W+I_{m}\varphi^{2}\right)^{-1}}_{m\times m\text{ inversion}}W^{T}\right)/\varphi^{2}\\ &amp; =\left(I_{d}-WM^{-1}W^{T}\right)/\varphi^{2} \end{align}\] <p>Instead of inverting the full $d\times d$ matrix, it turns out that it’s enough to invert the $m\times m$ matrix:</p> \[\begin{equation} M=W^{T}W+I_{m}\varphi^{2} \end{equation}\] <p>But this is still a $d\times d$ matrix, so in the face of it we still didn’t gain all that much by this change (although, believe me, inverting a small matrix instead of a big matrix is already an improvement).</p> <p>In fact, most of the times we don’t need just the inverse of the covariance (also called the precision, by the way). We need the precision matrix times some vector:</p> \[\begin{equation} \Sigma_{W}^{-1}v=\frac{1}{\varphi^{2}}v-\frac{1}{\varphi^{2}}\underbrace{WM^{-1}}_{\in\mathbb{R}^{d\times m}}\underbrace{W^{T}v}_{\in\mathbb{R}^{m}} \end{equation}\] <p>Beyond the fact that this takes much less time, the numerical stability of this operation is much better than if we were to invert a $d\times d$ matrix.</p> <p>The last thing to note is that the posterior is also completely tractable and equal to:</p> \[\begin{equation} p_{\theta}\left(z|x\right)=\mathcal{N}\left(z|\;M^{-1}W^{T}\left(x-\mu\right),M/\varphi^{2}\right) \end{equation}\] <p>This being easy to calculate means that (given an observed $x$) we can carry out all needed operations in the latent dimension with ease. This is sometimes difficult to do, as we will see in the next parts of this primer.</p> <p><br></p> <h1 id="conclusion"><strong>Conclusion</strong></h1> <d-byline></d-byline> <p>The pPCA model is one of the simplest generative models one can use for continuous data. It’s basically a Gaussian with most of the probability concentrated around a lower-dimensional projection. Because this model is so simple, it serves as a good baseline. Also, it allows us to do solve many tasks with a closed-form solution, which is really rare for generative models.</p> <p>So, where do we proceed? The obvious next step after a linear model is one that isn’t linear. This turns out to complicate matters considerably. In the next post, we’ll take a look at variation methods (such as variational auto-encoders), which give us a framework for training and using non-linear models in inference tasks.</p> <p><br></p> <d-byline></d-byline> <p><span style="float:left"><a href="https://friedmanroy.github.io/blog/2024/gen0/">← What is a Generative Model?</a></span><span style="float:right"><a href="https://friedmanroy.github.io/blog/2024/gen2/">Variational Methods →</a></span></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/primer_generative_biblio.bib"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Roy Friedman. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener noopener noreferrer" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1B05NVC2PJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1B05NVC2PJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>